<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neon Wordle â€” Unlimited</title>
    <style>
      :root {
        --bg0: #0a0b0f;
        --bg1: #0e1018;
        --panel: #141724;
        --panel-2: #121523;
        --text: #e6e7ee;
        --muted: #9aa0b4;
        --key-text: #e6e7ee;
        --tile-text: #f5f7ff;
        --absent: #3f4458;
        --present: #ffdc5e;
        --correct: #2ee865;
        --accent: #00e5ff;
        --accent-2: #ff38c7;
        --toast-bg: rgba(10, 12, 20, 0.9);
        --white: #fff;
        --boardW: 520px; /* used to place side toast */
        --glow: 0 0 12px rgba(0,229,255,0.45), 0 0 32px rgba(0,229,255,0.25);
        --glow-mag: 0 0 12px rgba(255,56,199,0.45), 0 0 32px rgba(255,56,199,0.25);
  --gap: 8px; /* board/key spacing */
      }
      
  /* Prevent padding from causing overflow and right-side gaps */
  *, *::before, *::after { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--text);
        background:
          radial-gradient(1000px 800px at 10% 10%, rgba(0,229,255,0.12), transparent 60%),
          radial-gradient(900px 700px at 80% 20%, rgba(255,56,199,0.10), transparent 60%),
          linear-gradient(180deg, var(--bg1), var(--bg0));
        background-attachment: fixed;
        overflow-x: hidden;
      }
  /* Improve touch feel on mobile */
  * { -webkit-tap-highlight-color: rgba(0,0,0,0); }

      /* subtle cookie speckles */
      body::before {
        content: '';
        position: fixed; inset: 0;
        pointer-events: none;
        background:
          radial-gradient(400px 400px at 20% 80%, rgba(0,229,255,0.08), transparent 70%),
          radial-gradient(350px 350px at 80% 70%, rgba(255,56,199,0.08), transparent 70%);
        mix-blend-mode: screen;
      }

  /* no cookie crisps in neon theme */

  header { position: sticky; top: 0; z-index: 5; background: linear-gradient(180deg, rgba(10,12,20,0.8), rgba(10,12,20,0.5)); backdrop-filter: blur(6px); border-bottom: 1px solid rgba(0,229,255,0.2); }
  .header-inner { width: 100%; max-width: 760px; margin: 0 auto; padding: 12px 16px; display: flex; align-items: center; justify-content: space-between; gap: 12px; position: relative; }
  .brand { display: flex; align-items: center; gap: 10px; font-weight: 800; letter-spacing: 1px; color: var(--text); }
  .brand .cookie { width: 28px; height: 28px; border-radius: 50%; background: radial-gradient(16px 16px at 35% 35%, var(--accent) 0, rgba(0,229,255,0.15) 60%, transparent 70%), radial-gradient(10px 10px at 70% 60%, var(--accent-2) 0, rgba(255,56,199,0.12) 60%, transparent 70%); box-shadow: var(--glow), var(--glow-mag); }
  .brand span { font-size: 18px; color: var(--text); }

      .stats {
        display: flex; gap: 10px; align-items: center; font-size: 12px; opacity: 0.9;
      }
  .stat { background: rgba(20,23,36,0.8); border: 1px solid rgba(0,229,255,0.2); border-radius: 10px; padding: 6px 10px; min-width: 52px; text-align: center; box-shadow: 0 0 10px rgba(0,229,255,0.15) inset; color: var(--muted); }
      .controls { display: flex; gap: 8px; align-items: center; }
  .btn { appearance: none; border: 1px solid rgba(0,229,255,0.35); background: linear-gradient(180deg, #1a1f33, #12172a); color: var(--text); border-radius: 10px; padding: 8px 12px; font-weight: 700; box-shadow: var(--glow); cursor: pointer; }
      .btn:active { transform: translateY(1px); }

      main { max-width: 1040px; margin: 16px auto; padding: 0 16px calc(28px + env(safe-area-inset-bottom, 0px)); }

      /* Layout with optional left sidebar (leaderboard) */
  .layout { display: grid; grid-template-columns: 1fr; gap: 16px; align-items: start; }
      .sidebar { display: none; background: linear-gradient(180deg, var(--panel), var(--panel-2)); border-radius: 16px; border: 1px solid rgba(0,229,255,0.25); box-shadow: 0 12px 28px rgba(0,0,0,0.35), inset 0 0 18px rgba(0,229,255,0.08); padding: 12px; }
      .sidebar h3 { margin: 6px 8px 10px; font-size: 14px; font-weight: 800; letter-spacing: .5px; color: var(--text); }
      .leader-scroll { max-height: 520px; overflow: auto; border-radius: 10px; border: 1px solid rgba(0,229,255,0.18); }
      table.leader { width: 100%; border-collapse: collapse; font-size: 13px; }
      .leader thead th { position: sticky; top: 0; background: #12172a; color: var(--muted); text-align: left; padding: 8px 10px; border-bottom: 1px solid rgba(0,229,255,0.18); }
      .leader tbody td { padding: 8px 10px; border-bottom: 1px solid rgba(0,229,255,0.1); }
      .leader tbody tr:hover { background: rgba(0,229,255,0.05); }
      .leader .col-r { text-align: right; }

      /* Leaderboard button visibility: show on small screens, hide when sidebar is visible */
      #btn-leader { display: inline-flex; }
  #btn-daily, #btn-normal { display: inline-flex; }
      @media (min-width: 980px) {
        .sidebar { display: block; }
        #btn-leader { display: none; }
        .layout { grid-template-columns: 340px 1fr; }
      }

  .board-wrap { background: linear-gradient(180deg, var(--panel), var(--panel-2)); border-radius: 16px; border: 1px solid rgba(0,229,255,0.25); box-shadow: 0 12px 28px rgba(0,0,0,0.35), inset 0 0 18px rgba(0,229,255,0.08); padding: 16px; margin: 0 auto 16px; width: 100%; max-width: var(--boardW); }
      .board {
        display: grid; grid-template-rows: repeat(6, 1fr); gap: var(--gap);
        width: 100%; max-width: 480px; aspect-ratio: 5/6; margin: 0 auto;
      }
      .row { display: grid; grid-template-columns: repeat(5, 1fr); gap: var(--gap); }

  .tile { position: relative; display: grid; place-items: center; font-weight: 800; font-size: clamp(18px, 7vw, 28px); color: var(--tile-text); background: linear-gradient(180deg, #1a1f33, #111526); border: 2px solid rgba(0,229,255,0.25); border-radius: 12px; box-shadow: inset 0 0 10px rgba(0,229,255,0.08); text-transform: uppercase; transform-style: preserve-3d; transition: transform 0.3s ease, border-color .2s ease, box-shadow .2s ease; }

      .tile.revealed { transition: transform 0.6s cubic-bezier(.2,.7,.2,1); }
      .tile.flip { transform: rotateX(90deg); }

  .tile.absent { background: #252a3a; color: var(--white); border-color: #394058; }
  .tile.present { background: #554400; color: #ffe57a; border-color: #ffdc5e; box-shadow: 0 0 10px rgba(255,220,94,0.35); }
  .tile.correct { background: #003d22; color: #a6ffd0; border-color: var(--correct); box-shadow: 0 0 12px rgba(46,232,101,0.45); }
  .tile.hint { border-color: var(--accent); box-shadow: 0 0 12px rgba(0,229,255,0.55); }

      .tile.pop { animation: pop 100ms ease-out; }
      @keyframes pop { 0% { transform: scale(0.9); } 100% { transform: scale(1); } }
      .row.shake { animation: shake 300ms ease-in-out; }
      @keyframes shake { 10%, 90% { transform: translateX(-2px); } 20%, 80% { transform: translateX(3px); } 30%, 50%, 70% { transform: translateX(-5px); } 40%, 60% { transform: translateX(5px);} }
      .row.bounce { animation: bounce 600ms ease-in-out; }
      @keyframes bounce { 0%, 100% { transform: translateY(0); } 30% { transform: translateY(-6px); } }

  .keyboard { width: 100%; max-width: 520px; margin: 0 auto; display: grid; gap: var(--gap); }
  .key-row { display: grid; grid-auto-flow: column; grid-auto-columns: 1fr; gap: var(--gap); }
  .key { user-select: none; cursor: pointer; text-transform: uppercase; font-weight: 700; font-size: clamp(12px, 3.5vw, 14px); padding: clamp(8px, 2.4vw, 12px) 6px; text-align: center; border-radius: 10px; color: var(--key-text); background: linear-gradient(180deg, #1a1f33, #12172a); border: 2px solid rgba(0,229,255,0.25); box-shadow: inset 0 0 10px rgba(0,229,255,0.08); }
      .key:active { transform: translateY(1px); }
  .key.absent { background: #252a3a; color: var(--white); border-color: #394058; }
  .key.present { background: #554400; color: #ffe57a; border-color: #ffdc5e; box-shadow: 0 0 10px rgba(255,220,94,0.35) inset; }
  .key.correct { background: #003d22; color: #a6ffd0; border-color: var(--correct); box-shadow: 0 0 12px rgba(46,232,101,0.45) inset; }
      .key.wide { grid-column: span 1; font-size: 12px; }
      .key.backspace { font-size: 12px; }
      .key[disabled] {
        pointer-events: none;
        opacity: 0.6;
        filter: grayscale(25%);
        cursor: not-allowed;
      }

  .toast { position: fixed; top: 18px; left: 50%; transform: translateX(-50%); background: var(--toast-bg); color: #e6f7ff; padding: 10px 12px; border-radius: 10px; font-weight: 700; box-shadow: 0 0 18px rgba(0,229,255,0.4); opacity: 0; pointer-events: none; transition: opacity .2s ease, transform .2s ease; z-index: 10000; }
      .toast.show { opacity: 1; transform: translate(-50%, 4px); }

      /* Side placement relative to centered board */
      @media (min-width: 900px) {
        .toast.side { top: 110px; left: 50%; transform: translateX(calc(var(--boardW) / 2 + 44px)); }
        .toast.side.show { transform: translate(calc(var(--boardW) / 2 + 44px), 4px); }
        .toast.side.left { transform: translateX(calc(-1 * (var(--boardW) / 2 + 44px))); }
        .toast.side.left.show { transform: translate(calc(-1 * (var(--boardW) / 2 + 44px)), 4px); }
      }

      /* Mobile optimizations */
      @media (max-width: 480px) {
        .header-inner { padding: 10px 12px; }
        .btn { padding: 6px 10px; }
        .board-wrap { padding: 12px; border-radius: 12px; }
        :root { --gap: 6px; }
  .header-inner { flex-wrap: wrap; gap: 8px; }
  .controls { flex-wrap: wrap; gap: 6px; }
  .stats { flex-wrap: wrap; gap: 6px; }
  .stat { padding: 4px 8px; min-width: auto; font-size: 11px; }
  .brand span { font-size: 16px; }
      }
      @media (max-width: 360px) {
        :root { --gap: 4px; }
        .board-wrap { padding: 10px; }
  .brand span { font-size: 15px; }
  .stat { font-size: 10px; }
      }

      .sr-only { position: absolute; left: -10000px; top: auto; width: 1px; height: 1px; overflow: hidden; }

  /* Modal base styles (for nickname and mobile leaderboard) */
  .modal-backdrop { position: fixed; inset: 0; background: rgba(6,8,14,0.7); backdrop-filter: blur(4px); display: none; align-items: center; justify-content: center; z-index: 10001; }
  .modal-backdrop.show { display: flex; }
  .modal-card { width: min(92vw, 520px); background: linear-gradient(180deg, #1a1f33, #12172a); border: 1px solid rgba(0,229,255,0.3); border-radius: 14px; box-shadow: var(--glow); color: var(--text); }
  .modal-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 14px; border-bottom: 1px solid rgba(0,229,255,0.18); }
  .modal-title { font-weight: 800; letter-spacing: .6px; }
  .modal-body { padding: 14px; }
  .modal-footer { padding: 12px 14px; display: flex; align-items: center; justify-content: flex-end; gap: 8px; border-top: 1px solid rgba(0,229,255,0.18); }
  .input { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(0,229,255,0.25); background: #0f1324; color: var(--text); font-weight: 700; letter-spacing: .4px; }
  .help { color: var(--muted); font-size: 12px; margin-top: 6px; }
  .error { color: #ff6b8a; font-size: 12px; margin-top: 6px; font-weight: 700; }
    </style>
  </head>
  <body>
    <header>
      <div class="header-inner">
        <div class="brand">
          <div class="cookie" aria-hidden="true"></div>
          <span>Neon Wordle</span>
        </div>
  <div class="controls">
          <div class="stats">
            <div class="stat" title="Games played">GP <span id="stat-played">0</span></div>
            <div class="stat" title="Win %">W% <span id="stat-win">0</span></div>
            <div class="stat" title="Current streak">CS <span id="stat-streak">0</span></div>
            <div class="stat" title="Max streak">MS <span id="stat-max">0</span></div>
          </div>
          <button id="btn-hint" class="btn" aria-label="Reveal a letter hint">Hint</button>
          <button id="btn-new" class="btn" aria-label="Start next word">Next word</button>
          <button id="btn-daily" class="btn" title="Switch to Daily Mode">Daily Mode</button>
          <button id="btn-normal" class="btn" style="display:none" title="Switch to Normal Mode">Normal Mode</button>
          <button id="btn-leader" class="btn" aria-haspopup="dialog" aria-controls="modal-leader" title="Show leaderboards">Leaderboards</button>
          <button id="btn-change-nick" class="btn" title="Change your nickname">Change Nickname</button>
        </div>
  
      </div>
    </header>

    <!-- Daily countdown timer area -->
    <div id="daily-timer-wrap" style="display:none; width:100%; background: linear-gradient(180deg, rgba(0,229,255,0.08), rgba(255,56,199,0.06)); border-bottom:1px solid rgba(0,229,255,0.18);">
      <div style="max-width:760px; margin:0 auto; padding:8px 16px; display:flex; align-items:center; justify-content:center; gap:10px; text-align:center;">
        <strong style="letter-spacing:.4px;">Daily Mode</strong>
        <span id="daily-timer" style="color:var(--muted)">Next word in 00:00:00</span>
      </div>
    </div>

    <main>
      <div class="layout">
        <aside id="sidebar" class="sidebar" aria-label="Global Leaderboard">
          <h3>Global Leaderboard</h3>
          <div class="leader-scroll">
            <table class="leader" aria-describedby="leader-desc">
              <thead>
                <tr><th>Nickname</th><th class="col-r">Total Guessed</th><th class="col-r">Win %</th></tr>
              </thead>
              <tbody id="leader-tbody"><tr><td colspan="3" style="padding:10px 12px;color:var(--muted)">Loadingâ€¦</td></tr></tbody>
            </table>
          </div>
          <div id="leader-desc" class="sr-only">Sorted by total words guessed descending. Scroll if long.</div>
        </aside>
        <section>
          <div class="board-wrap">
  <div id="board" class="board" role="application" aria-label="Neon Wordle board">
          <!-- rows/tiles injected -->
        </div>
            <!-- Daily result banner (shown after playing the daily) -->
            <div id="daily-result" style="display:none; text-align:center; padding:14px; font-weight:800; border:1px dashed rgba(0,229,255,0.35); border-radius:12px; margin-top:8px;">
              <span id="daily-result-text">The word of the day was: </span>
            </div>
          </div>
          <div id="keyboard" class="keyboard" aria-label="On-screen keyboard">
            <div class="key-row" id="kb-row-1"></div>
            <div class="key-row" id="kb-row-2"></div>
            <div class="key-row" id="kb-row-3"></div>
          </div>
        </section>
      </div>
    </main>

    <footer style="width:100%; text-align:center; color:var(--muted); font-size:12px; padding:12px 8px; opacity:0.85;">
      v1.0 by Yozhik â€” Player: <span id="nick-footer">Guest</span>
    </footer>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>
    <div class="sr-only" aria-live="polite" id="sr"></div>

    <!-- Nickname Modal -->
    <div id="modal-nick" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="nick-title">
      <div class="modal-card">
        <div class="modal-header">
          <div id="nick-title" class="modal-title">Choose your nickname</div>
        </div>
        <div class="modal-body">
          <label for="nick-input" style="display:block; font-weight:700; margin-bottom:6px;">Nickname</label>
          <input id="nick-input" class="input" maxlength="12" placeholder="letters and digits only" autocomplete="off" />
          <div class="help">Required to play. 1â€“12 chars, Aâ€“Z and 0â€“9 only. Unique globally.</div>
          <div id="nick-error" class="error" role="alert" style="display:none"></div>
        </div>
        <div class="modal-footer">
          <button id="nick-confirm" class="btn">Save</button>
        </div>
      </div>
    </div>

    <!-- Leaderboard Modal (mobile) -->
    <div id="modal-leader" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="leader-title">
      <div class="modal-card" style="width:min(96vw,700px)">
        <div class="modal-header">
          <div id="leader-title" class="modal-title">Global Leaderboard</div>
          <button id="leader-close" class="btn" aria-label="Close">Close</button>
        </div>
        <div class="modal-body">
          <div class="leader-scroll" style="max-height:60vh">
            <table class="leader">
              <thead>
                <tr><th>Nickname</th><th class="col-r">Total Guessed</th><th class="col-r">Win %</th></tr>
              </thead>
              <tbody id="leader-tbody-modal"><tr><td colspan="3" style="padding:10px 12px;color:var(--muted)">Loadingâ€¦</td></tr></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

  <!-- Removed embedded word bank: now selecting solutions from dict5.txt only -->

  <script>
    // Global leaderboard: Supabase config (public anon key)
    window.LEADERBOARD_API = {
      type: 'supabase',
      url: 'https://jmcjlvukbuqsickepjbp.supabase.co',
      key: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImptY2psdnVrYnVxc2lja2VwamJwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUwOTMyOTUsImV4cCI6MjA3MDY2OTI5NX0.g-PoNyO_c9NFZMqPA8zM5LfhUuCzGY9UCYYvY5h8vIc',
      schema: 'public',
    table: 'players',
    tableDaily: 'daily',
    secure: true
    };
  </script>
  <!-- supabase-js UMD (for secure RPC and auth) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>


    <script>
      // Dictionary of acceptable English 5-letter words (fetched from dict5.txt)
      const DICT5 = new Set();
      let dictReady = false; let dictLoading = false;
      function loadDict(){
        if (dictReady || dictLoading) return;
        dictLoading = true;
        fetch('dict5.txt', { cache: 'no-store' })
          .then(r => r.ok ? r.text() : Promise.reject(r.status))
          .then(txt => {
            txt.split(/\r?\n/).forEach(w => { const s=w.trim(); if (s) DICT5.add(s); });
            dictReady = DICT5.size > 0;
            if (dictReady) { window._DICT5_ARR = Array.from(DICT5); }
            // If user is ready to play but we had no solution yet, start a round now
            if (dictReady && playerNick && !solution) { resetGame(); }
          })
          .catch(() => { dictReady = false; })
          .finally(() => { dictLoading = false; });
      }
      loadDict();
      // Dictionary of acceptable English 6-letter words (daily mode)
      const DICT6 = new Set();
      let dict6Ready = false; let dict6Loading = false;
      // Small built-in fallback so Daily works even if dict6.txt can't be fetched (e.g., file:// CORS)
      const FALLBACK6 = [
        'abroad','animal','planet','silver','little','public','random','orange','police','summer','winter','garden','friend','modern','mirror','select','sister','market','marine','forget','prefer','thirty','visual'
      ];
      function loadDict6(){
        if (dict6Ready || dict6Loading) return;
        dict6Loading = true;
        fetch('dict6.txt', { cache: 'no-store' })
          .then(r => r.ok ? r.text() : Promise.reject(r.status))
          .then(txt => {
            // Accept strictly 6-letter alphabetic words only, normalized to lowercase
            txt.split(/\r?\n/).forEach(w => {
              const s = (w||'').trim().toLowerCase();
              if (s && /^[a-z]{6}$/.test(s)) DICT6.add(s);
            });
            dict6Ready = DICT6.size > 0;
            if (dict6Ready) { window._DICT6_ARR = Array.from(DICT6); }
            if (dict6Ready && mode === MODE_DAILY && playerNick && (!solution || solution.length !== 6)) {
              setupDailyWord();
            }
          })
          .catch(() => { dict6Ready = false; })
          .finally(() => { dict6Loading = false; });
      }

      // --- Leaderboard and nickname gating ---
      const btnLeader = document.getElementById('btn-leader');
  const btnChangeNick = document.getElementById('btn-change-nick');
      const sidebarEl = document.getElementById('sidebar');
      const leaderBody = document.getElementById('leader-tbody');
      const leaderBodyModal = document.getElementById('leader-tbody-modal');
      const modalNick = document.getElementById('modal-nick');
      const nickInput = document.getElementById('nick-input');
      const nickConfirm = document.getElementById('nick-confirm');
      const nickError = document.getElementById('nick-error');
      const modalLeader = document.getElementById('modal-leader');
      const leaderClose = document.getElementById('leader-close');
  const leaderTitleAside = document.querySelector('.sidebar h3');
  const leaderTitleModal = document.getElementById('leader-title');

      function openModal(m){ m.classList.add('show'); }
      function closeModal(m){ m.classList.remove('show'); }
      function sanitize(text){
        const map = { '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#39;' };
        return String(text).replace(/[&<>"']/g, ch => map[ch]);
      }

      // Provider abstraction; default Local fallback. To enable global sync, set window.LEADERBOARD_API with endpoints.
      class LocalLeaderboard {
        constructor(){
          this.key = 'leader_local_players';
          this.map = this._load();
        }
        _load(){ try { return new Map(Object.entries(JSON.parse(localStorage.getItem(this.key)||'{}'))); } catch { return new Map(); } }
        _save(){ const obj = Object.fromEntries(this.map); localStorage.setItem(this.key, JSON.stringify(obj)); }
        async exists(nick){ return this.map.has(nick.toLowerCase()); }
        async register(nick){ const k = nick.toLowerCase(); if (this.map.has(k)) throw new Error('exists'); this.map.set(k, { nick, wins: 0, played: 0 }); this._save(); return true; }
        async upsert(nick, totals){ const k = nick.toLowerCase(); const cur = this.map.get(k) || { nick, wins: 0, played: 0 }; this.map.set(k, { nick, wins: Math.max(totals.wins, cur.wins), played: Math.max(totals.played, cur.played) }); this._save(); return true; }
        async delete(nick){ const k = nick.toLowerCase(); this.map.delete(k); this._save(); return true; }
        async list(){ return Array.from(this.map.values()); }
      }

      // Optional remote REST provider. Set window.LEADERBOARD_API = { baseUrl: 'https://your.api', apiKey: 'optional' }.
      class RemoteLeaderboard {
        constructor(cfg){ this.cfg = cfg; }
        async _fetch(path, opts={}){
          const headers = Object.assign({ 'Content-Type': 'application/json' }, this.cfg.apiKey ? { 'Authorization': `Bearer ${this.cfg.apiKey}` } : {});
          const res = await fetch(`${this.cfg.baseUrl}${path}`, { ...opts, headers });
          if (!res.ok) throw new Error(`http ${res.status}`);
          return res.json();
        }
        async exists(nick){ const j = await this._fetch(`/players/exists?nick=${encodeURIComponent(nick)}`); return !!j.exists; }
        async register(nick){ const j = await this._fetch(`/players`, { method:'POST', body: JSON.stringify({ nick }) }); if (j && j.error) throw new Error(j.error); return true; }
        async upsert(nick, totals){ const j = await this._fetch(`/players/${encodeURIComponent(nick)}`, { method:'PUT', body: JSON.stringify(totals) }); if (j && j.error) throw new Error(j.error); return true; }
        async delete(nick){ await this._fetch(`/players/${encodeURIComponent(nick)}`, { method: 'DELETE' }); return true; }
        async list(){ return this._fetch(`/players`); }
      }

      // Supabase REST provider
      // window.LEADERBOARD_API example:
      // { type: 'supabase', url: 'https://PROJECT.supabase.co', key: 'ANON_KEY', schema: 'public', table: 'players' }
      class SupabaseLeaderboard {
        constructor(cfg){
          this.url = cfg.url.replace(/\/$/, '');
          this.key = cfg.key;
          this.schema = cfg.schema || 'public';
          this.table = cfg.table || 'players';
        }
        _headers(extra={}){
          return Object.assign({
            'apikey': this.key,
            'Authorization': `Bearer ${this.key}`,
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Prefer': 'return=minimal'
          }, extra);
        }
        async exists(nick){
          const res = await fetch(`${this.url}/rest/v1/${this.table}?select=nick&nick=eq.${encodeURIComponent(nick)}`, { headers: this._headers() });
          if (!res.ok) throw new Error(`http ${res.status}`);
          const arr = await res.json();
          return Array.isArray(arr) && arr.length > 0;
        }
        async register(nick){
          const body = JSON.stringify({ nick, wins: 0, played: 0 });
          const res = await fetch(`${this.url}/rest/v1/${this.table}`, { method: 'POST', headers: this._headers({ 'Prefer': 'return=representation' }), body });
          if (res.status === 409) throw new Error('exists');
          if (!res.ok) throw new Error(`http ${res.status}`);
          return true;
        }
        async upsert(nick, totals){
          // Upsert via POST with merge duplicates (requires unique index on nick)
          const body = JSON.stringify({ nick, wins: totals.wins|0, played: totals.played|0 });
          const headers = this._headers({ 'Prefer': 'resolution=merge-duplicates,return=minimal' });
          const res = await fetch(`${this.url}/rest/v1/${this.table}`, { method: 'POST', headers, body });
          if (!res.ok && res.status !== 409) throw new Error(`http ${res.status}`);
          return true;
        }
        async delete(nick){
          const res = await fetch(`${this.url}/rest/v1/${this.table}?nick=eq.${encodeURIComponent(nick)}`, { method: 'DELETE', headers: this._headers({ 'Prefer': 'return=minimal' }) });
          if (!res.ok) throw new Error(`http ${res.status}`);
          return true;
        }
        async list(){
          const res = await fetch(`${this.url}/rest/v1/${this.table}?select=nick,wins,played`, { headers: this._headers() });
          if (!res.ok) throw new Error(`http ${res.status}`);
          return res.json();
        }
      }

      // Secure Supabase provider using supabase-js, RPC, and server-side computed updates
      class SupabaseSecureBase {
        constructor(cfg){
          this.cfg = cfg; this.url = cfg.url.replace(/\/$/, ''); this.key = cfg.key;
          if (!window.supabase) throw new Error('supabase-js not loaded');
          this.sb = window.supabase.createClient(this.url, this.key);
          this._authReady = false;
        }
        async ensureAuth(){
          if (this._authReady) return;
          try {
            const { data: { session } } = await this.sb.auth.getSession();
            if (!session) {
              // anonymous auth (requires enabling in your project; otherwise use OAuth/Magic Link)
              await this.sb.auth.signInAnonymously();
            }
            this._authReady = true;
          } catch(e) { /* ignore; views are still readable anon */ }
        }
        async rpc(name, params){ await this.ensureAuth(); const { data, error } = await this.sb.rpc(name, params || {}); if (error) throw error; return data; }
        async select(view, columns='*', match){ const q = this.sb.from(view).select(columns); if (match) Object.entries(match).forEach(([k,v])=> q.eq(k,v)); const { data, error } = await q; if (error) throw error; return data; }
      }

      class SupabaseSecureLeaderboard extends SupabaseSecureBase {
        constructor(cfg){ super(cfg); this.isSecure = true; }
        async exists(nick){
          try {
            const { data, error } = await this.sb.from('leaderboard_players')
              .select('nick')
              .ilike('nick', nick) // case-insensitive exact match
              .limit(1);
            if (error) return false;
            return Array.isArray(data) && data.length > 0;
          } catch { return false; }
        }
        async register(nick){ await this.rpc('set_nick', { p_nick: nick }); return true; }
  async upsert(_nick, _totals){ /* server computes totals; no-op here */ return true; }
  async delete(_nick){ /* not supported securely; no-op */ return true; }
  async list(){ return this.select('leaderboard_players', 'nick,wins,played'); }
  async submitNormal(win){ const nick = (typeof playerNick !== 'undefined' && playerNick) ? playerNick : null; await this.rpc('submit_normal_result', { p_nick: nick, p_win: !!win }); }
      }

      class SupabaseSecureDaily extends SupabaseSecureBase {
        constructor(cfg){ super(cfg); this.isSecure = true; }
        async get(nick){ const rows = await this.select('leaderboard_daily', 'nick,streak,today_rows,last_played', { nick }); return rows && rows[0] || null; }
        async delete(_nick){ /* not supported securely; no-op */ return true; }
  async upsertResult(_nick, payload){ return this.submitDaily(!!payload.win, payload.attempts|0); }
  async submitDaily(win, attempts){ const nick = (typeof playerNick !== 'undefined' && playerNick) ? playerNick : null; await this.rpc('submit_daily_result', { p_nick: nick, p_win: !!win, p_attempts: attempts|0 }); }
        async list(){ return this.select('leaderboard_daily', 'nick,streak,today_rows,last_played'); }
      }

  let provider = null;
  const LB = window.LEADERBOARD_API || null;
  if (LB && LB.type === 'supabase' && LB.url && LB.key) {
    provider = LB.secure ? new SupabaseSecureLeaderboard(LB) : new SupabaseLeaderboard(LB);
  }
  else if (LB && LB.baseUrl) provider = new RemoteLeaderboard(LB);
  else provider = new LocalLeaderboard();

      // Daily leaderboard providers
      class LocalDailyLeaderboard {
        constructor(){ this.key = 'leader_daily_local'; this.map = this._load(); }
        _load(){ try { return new Map(Object.entries(JSON.parse(localStorage.getItem(this.key)||'{}'))); } catch { return new Map(); } }
        _save(){ const obj = Object.fromEntries(this.map); localStorage.setItem(this.key, JSON.stringify(obj)); }
        async get(nick){ return this.map.get(nick.toLowerCase()) || null; }
  async delete(nick){ const k = nick.toLowerCase(); this.map.delete(k); this._save(); return true; }
        async upsertResult(nick, payload){
          const k = nick.toLowerCase();
          const cur = this.map.get(k) || { nick, streak: 0, today_rows: null, last_played: null };
          const { win, attempts, dateIso } = payload;
          const last = cur.last_played;
          const sameDay = last === dateIso;
          // missed day if last and date gap > 1: simple string compare not enough, ignore in local
          let streak = cur.streak|0;
          if (!sameDay && last && last !== dateIso) {
            // naive missed-day reset if last < dateIso (string works for ISO)
            if (last < dateIso) {
              // if gap > 1 day, reset
              // not computing actual gap here
              streak = 0;
            }
          }
          if (sameDay) {
            // don't change streak second time; update today_rows to min if win
            if (win) cur.today_rows = cur.today_rows ? Math.min(cur.today_rows, attempts) : attempts;
          } else {
            if (win) streak = streak + 1; else streak = 0;
            cur.today_rows = win ? attempts : 6;
            cur.last_played = dateIso;
          }
          cur.streak = streak; if (!cur.last_played) cur.last_played = dateIso;
          this.map.set(k, cur); this._save(); return true;
        }
        async list(){ return Array.from(this.map.values()); }
      }
      class SupabaseDailyLeaderboard {
        constructor(cfg){ this.url = cfg.url.replace(/\/$/, ''); this.key = cfg.key; this.table = cfg.tableDaily || 'daily'; }
        _headers(extra={}){ return Object.assign({ 'apikey': this.key, 'Authorization': `Bearer ${this.key}`, 'Content-Type': 'application/json', 'Accept': 'application/json', 'Prefer': 'return=minimal' }, extra); }
        async get(nick){ const res = await fetch(`${this.url}/rest/v1/${this.table}?select=nick,streak,today_rows,last_played&nick=eq.${encodeURIComponent(nick)}`, { headers: this._headers() }); if (!res.ok) throw new Error(`http ${res.status}`); const arr = await res.json(); return Array.isArray(arr)&&arr.length?arr[0]:null; }
  async delete(nick){ const res = await fetch(`${this.url}/rest/v1/${this.table}?nick=eq.${encodeURIComponent(nick)}`, { method:'DELETE', headers: this._headers() }); if (!res.ok) throw new Error(`http ${res.status}`); return true; }
        async upsertRow(obj){ const headers = this._headers({ 'Prefer': 'resolution=merge-duplicates,return=minimal' }); const res = await fetch(`${this.url}/rest/v1/${this.table}`, { method:'POST', headers, body: JSON.stringify(obj) }); if (!res.ok && res.status !== 409) throw new Error(`http ${res.status}`); return true; }
        async upsertResult(nick, payload){
          const { win, attempts, dateIso } = payload;
          let cur = null; try { cur = await this.get(nick); } catch {}
          const last = cur?.last_played || null;
          const sameDay = last === dateIso;
          // detect missed day: if last exists and last < dateIso and not sameDay; we can't compute exact gap without time math; use simple check
          let streak = (cur?.streak|0) || 0;
          if (!sameDay && last && last < dateIso) {
            // We may be 1+ days ahead; reset if missed at least one day. We'll reset now and then apply win rule.
            // If playing the next day without missing, last === yesterday, but we can't check precisely; assume increment anyway; acceptable for client-side.
            // To avoid false reset for consecutive days, we'll only reset if win===false (failure) or if date gap is likely > 1 by simple string compare of day digits
          }
          const data = { nick, streak: 0, today_rows: null, last_played: dateIso };
          if (sameDay) {
            data.streak = streak; data.today_rows = win ? Math.min(cur?.today_rows||attempts, attempts) : 6; data.last_played = dateIso;
          } else {
            if (win) data.streak = (last && last < dateIso) ? streak + 1 : (streak ? streak + 1 : 1);
            else data.streak = 0;
            data.today_rows = win ? attempts : 6;
          }
          return this.upsertRow(data);
        }
        async list(){ const res = await fetch(`${this.url}/rest/v1/${this.table}?select=nick,streak,today_rows,last_played`, { headers: this._headers() }); if (!res.ok) throw new Error(`http ${res.status}`); return res.json(); }
      }

  let dailyProvider = null;
  if (LB && LB.type === 'supabase' && LB.url && LB.key) dailyProvider = LB.secure ? new SupabaseSecureDaily(LB) : new SupabaseDailyLeaderboard(LB);
  else dailyProvider = new LocalDailyLeaderboard();
      let playerNick = (localStorage.getItem('player_nick')||'').trim();
      let canPlay = false;
      let pendingOldNick = null; // when renaming, delete this after new nick is saved

      function validateNick(n){ return /^[A-Za-z0-9]{1,12}$/.test(n); }
      async function ensureNickname(){
        if (playerNick) { canPlay = true; return; }
        // show modal and gate gameplay; don't reset if already open (avoid clearing typed text)
        if (!modalNick.classList.contains('show')) {
          openModal(modalNick);
          nickInput.value = '';
          nickError.style.display = 'none';
          setTimeout(()=>nickInput.focus(), 50);
        }
        canPlay = false;
      }
      async function trySaveNick(){
        const n = nickInput.value.trim();
        if (!validateNick(n)) { nickError.textContent = 'Only Aâ€“Z, 0â€“9, up to 12 chars.'; nickError.style.display = 'block'; return; }
        try {
          const exists = await provider.exists(n);
          if (exists) { nickError.textContent = 'That nickname is taken. Try another.'; nickError.style.display = 'block'; return; }
          await provider.register(n);
          playerNick = n; localStorage.setItem('player_nick', n);
          nickError.style.display = 'none'; closeModal(modalNick); canPlay = true; showToast(`Welcome, ${n}!`);
          // Push current totals if any
          if (provider && provider.isSecure && typeof provider.register === 'function') {
            await provider.register(playerNick);
          } else {
            await provider.upsert(playerNick, { wins: stats.wins, played: stats.played });
          }
          // If renamed, delete previous nickname record
          if (pendingOldNick && pendingOldNick.toLowerCase() !== n.toLowerCase()) {
            try { await provider.delete(pendingOldNick); } catch {}
            try { if (dailyProvider && typeof dailyProvider.delete === 'function') await dailyProvider.delete(pendingOldNick); } catch {}
          }
          pendingOldNick = null;
          refreshLeaderboard();
          renderNickBadge();
        } catch (e) {
          nickError.textContent = 'Could not reserve nickname. Try again.'; nickError.style.display = 'block';
        }
      }
      nickConfirm.addEventListener('click', trySaveNick);
      nickInput.addEventListener('keydown', (e)=>{ if (e.key==='Enter') { e.preventDefault(); trySaveNick(); } });
      btnLeader.addEventListener('click', ()=> openModal(modalLeader));
      document.getElementById('leader-close').addEventListener('click', ()=> closeModal(modalLeader));
      btnChangeNick.addEventListener('click', ()=>{
        // Clear in-memory and stored nick and prompt again
        pendingOldNick = playerNick || null;
        playerNick = '';
        localStorage.removeItem('player_nick');
        ensureNickname();
        renderNickBadge();
      });

      function renderLeaderRows(rows){
        if (mode === MODE_DAILY) {
          const make = (arr) => arr.map(p => `<tr><td>${sanitize(p.nick)}</td><td class="col-r">${p.streak|0}</td><td class="col-r">${p.today_rows!=null?p.today_rows:'-'}</td></tr>`).join('');
          if (leaderBody) leaderBody.innerHTML = rows.length? make(rows) : '<tr><td colspan="3" style="padding:10px 12px;color:var(--muted)">No players yet.</td></tr>';
          if (leaderBodyModal) leaderBodyModal.innerHTML = leaderBody.innerHTML;
        } else {
          const make = (arr) => arr.map(p => `<tr><td>${sanitize(p.nick)}</td><td class="col-r">${p.wins}</td><td class="col-r">${p.played?Math.round((p.wins/p.played)*100):0}</td></tr>`).join('');
          if (leaderBody) leaderBody.innerHTML = rows.length? make(rows) : '<tr><td colspan="3" style="padding:10px 12px;color:var(--muted)">No players yet.</td></tr>';
          if (leaderBodyModal) leaderBodyModal.innerHTML = leaderBody.innerHTML;
        }
      }
      async function refreshLeaderboard(){
        try {
          if (mode === MODE_DAILY) {
            const todayIso = toKyivDate(new Date()).iso;
            // Map to ensure we only show rows for today; keep streak always
            const raw = await dailyProvider.list();
            const list = raw.map(p => ({
              nick: p.nick,
              streak: p.streak|0,
              today_rows: (p.last_played === todayIso) ? (p.today_rows ?? null) : null,
              last_played: p.last_played || null
            }));
            list.sort((a,b)=> (b.streak|0) - (a.streak|0) || ((a.today_rows ?? 999) - (b.today_rows ?? 999)) || a.nick.localeCompare(b.nick));
            // Update headers
            if (leaderTitleAside) leaderTitleAside.textContent = 'Daily Leaderboard';
            if (leaderTitleModal) leaderTitleModal.textContent = 'Daily Leaderboard';
            const theads = document.querySelectorAll('.leader thead');
            theads.forEach(th => th.innerHTML = '<tr><th>Nickname</th><th class="col-r">Winstreak</th><th class="col-r">Rows Today</th></tr>');
            renderLeaderRows(list);
          } else {
            const list = await provider.list();
            list.sort((a,b)=> b.wins - a.wins || ((b.wins/(b.played||1)) - (a.wins/(a.played||1))) || a.nick.localeCompare(b.nick));
            if (leaderTitleAside) leaderTitleAside.textContent = 'Global Leaderboard';
            if (leaderTitleModal) leaderTitleModal.textContent = 'Global Leaderboard';
            const theads = document.querySelectorAll('.leader thead');
            theads.forEach(th => th.innerHTML = '<tr><th>Nickname</th><th class="col-r">Total Guessed</th><th class="col-r">Win %</th></tr>');
            renderLeaderRows(list);
          }
        } catch {
          // ignore
        }
      }
  // periodic refresh
  setInterval(refreshLeaderboard, 20000);
  // Trigger two quick refreshes for faster first paint
  refreshLeaderboard();
  setTimeout(refreshLeaderboard, 300);

      // --- Game constants ---
    const ROWS = 6; let COLS = 5;
      const boardEl = document.getElementById('board');
      const toastEl = document.getElementById('toast');
      const srEl = document.getElementById('sr');
      const btnNew = document.getElementById('btn-new');
  const btnHint = document.getElementById('btn-hint');
  const btnDaily = document.getElementById('btn-daily');
  const btnNormal = document.getElementById('btn-normal');
  const dailyTimerWrap = document.getElementById('daily-timer-wrap');
  const dailyTimerEl = document.getElementById('daily-timer');
  const dailyResultBox = document.getElementById('daily-result');
  const dailyResultText = document.getElementById('daily-result-text');
  const keyboardWrap = document.getElementById('keyboard');
  const nickFooter = document.getElementById('nick-footer');

      // Stats
      const statPlayed = document.getElementById('stat-played');
      const statWin = document.getElementById('stat-win');
      const statStreak = document.getElementById('stat-streak');
      const statMax = document.getElementById('stat-max');

  // Guesses must be real words for each mode (validated against the dictionaries)

      function saveStats(s){ localStorage.setItem('cookie_wordle_stats', JSON.stringify(s)); }
      function loadStats(){
        try { return JSON.parse(localStorage.getItem('cookie_wordle_stats')) || { played: 0, wins: 0, streak: 0, maxStreak: 0 }; }
        catch { return { played: 0, wins: 0, streak: 0, maxStreak: 0 }; }
      }
      let stats = loadStats();
      function renderStats(){
        statPlayed.textContent = String(stats.played);
        statWin.textContent = stats.played ? String(Math.round((stats.wins / stats.played) * 100)) : '0';
        statStreak.textContent = String(stats.streak);
        statMax.textContent = String(stats.maxStreak);
      }
      renderStats();

      // Board generation (dynamic by COLS)
      const rows = [];
      const tiles = [];
      function rebuildBoard(){
        rows.splice(0, rows.length);
        tiles.splice(0, tiles.length);
        boardEl.innerHTML = '';
            // Adjust board aspect ratio to match columns
            try { boardEl.style.aspectRatio = `${COLS}/6`; } catch {}
        for (let r = 0; r < ROWS; r++) {
              const row = document.createElement('div'); row.className = 'row';
              // Dynamic columns per mode
              row.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
              rows.push(row);
          const rowTiles = [];
          for (let c = 0; c < COLS; c++) {
          const t = document.createElement('div'); t.className = 'tile'; t.setAttribute('data-row', r); t.setAttribute('data-col', c);
          // Unique cookie speckle pattern per tile via deterministic RNG
          let seed = (r * COLS + c + 1) * 97;
          const rng = () => { const s = Math.sin(seed++) * 10000; return s - Math.floor(s); };
          const rand = (a,b) => a + rng() * (b - a);
          t.style.setProperty('--t-s1r', `${Math.round(rand(6,10))}px`);
          t.style.setProperty('--t-s1x', `${Math.round(rand(55,80))}%`);
          t.style.setProperty('--t-s1y', `${Math.round(rand(20,60))}%`);
          t.style.setProperty('--t-s1a', `${rand(0.15,0.30).toFixed(2)}`);
          t.style.setProperty('--t-s2r', `${Math.round(rand(4,8))}px`);
          t.style.setProperty('--t-s2x', `${Math.round(rand(20,50))}%`);
          t.style.setProperty('--t-s2y', `${Math.round(rand(50,85))}%`);
          t.style.setProperty('--t-s2a', `${rand(0.12,0.24).toFixed(2)}`);
          t.style.setProperty('--t-s3r', `${Math.round(rand(3,7))}px`);
          t.style.setProperty('--t-s3x', `${Math.round(rand(35,60))}%`);
          t.style.setProperty('--t-s3y', `${Math.round(rand(15,40))}%`);
          t.style.setProperty('--t-s3a', `${rand(0.15,0.26).toFixed(2)}`);
          t.style.setProperty('--t-s4r', `${Math.round(rand(3,6))}px`);
          t.style.setProperty('--t-s4x', `${Math.round(rand(55,75))}%`);
          t.style.setProperty('--t-s4y', `${Math.round(rand(55,85))}%`);
          t.style.setProperty('--t-s4a', `${rand(0.12,0.22).toFixed(2)}`);
          row.appendChild(t); rowTiles.push(t);
        }
        tiles.push(rowTiles); boardEl.appendChild(row);
        }
      }
      rebuildBoard();

      // Keyboard
      const kb1 = 'qwertyuiop'.split('');
      const kb2 = 'asdfghjkl'.split('');
      const kb3 = ['enter', ...'zxcvbnm'.split(''), 'back'];
      const kbRows = [document.getElementById('kb-row-1'), document.getElementById('kb-row-2'), document.getElementById('kb-row-3')];
      const keyButtons = new Map();
      function mkKey(label) {
        const b = document.createElement('button');
        b.className = 'key' + (label==='enter' || label==='back' ? ' wide' : '');
        b.textContent = label === 'back' ? 'âŒ«' : (label === 'enter' ? 'Enter' : label);
        b.setAttribute('data-key', label);
        b.addEventListener('click', () => onKey(label));
        // Unique cookie look for each key
  const seedBase = label.split('').reduce((acc,ch,i)=> acc + ch.charCodeAt(0)*(i+1), 0) + 13;
  let seed = seedBase;
  const rng = () => { const s = Math.sin(seed++) * 10000; return s - Math.floor(s); };
  const rand = (a,b) => a + rng()*(b-a);
  b.style.setProperty('--k-s1r', `${Math.round(rand(5,8))}px`);
  b.style.setProperty('--k-s1x', `${Math.round(rand(65,90))}%`);
  b.style.setProperty('--k-s1y', `${Math.round(rand(15,45))}%`);
  b.style.setProperty('--k-s1a', `${rand(0.18,0.28).toFixed(2)}`);
  b.style.setProperty('--k-s2r', `${Math.round(rand(4,7))}px`);
  b.style.setProperty('--k-s2x', `${Math.round(rand(20,45))}%`);
  b.style.setProperty('--k-s2y', `${Math.round(rand(55,85))}%`);
  b.style.setProperty('--k-s2a', `${rand(0.12,0.22).toFixed(2)}`);
        keyButtons.set(label, b);
        return b;
      }
      kb1.forEach(k => kbRows[0].appendChild(mkKey(k)));
      kb2.forEach(k => kbRows[1].appendChild(mkKey(k)));
      kb3.forEach(k => kbRows[2].appendChild(mkKey(k)));

  // Modes
  const MODE_NORMAL = 'normal';
  const MODE_DAILY = 'daily';
  let mode = MODE_NORMAL;
  let dailyInterval = null; // countdown interval id
  let dailySeedDate = null; // YYYY-MM-DD (Kyiv)

  function toKyivDate(d){
    // Return an object with kyiv date components and formatted YYYY-MM-DD
    const parts = new Intl.DateTimeFormat('en-CA', { timeZone: 'Europe/Kyiv', year: 'numeric', month: '2-digit', day: '2-digit', hour12: false }).formatToParts(d);
    const get = k => parts.find(p=>p.type===k)?.value;
    const yyyy = get('year'); const mm = get('month'); const dd = get('day');
    return { yyyy, mm, dd, iso: `${yyyy}-${mm}-${dd}` };
  }

  function nextKyivMidnightMs(){
    const now = new Date();
    const f = new Intl.DateTimeFormat('en-CA', { timeZone: 'Europe/Kyiv', hour12:false, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit' });
    const parts = f.formatToParts(now);
    const get = k => parseInt(parts.find(p=>p.type===k)?.value||'0', 10);
    const yyyy = get('year'), mm = get('month'), dd = get('day');
    // Build next day 00:00:00 in Kyiv by using Date.UTC on components and adjusting via timezone offset of Kyiv at that moment via Intl
    // Simpler: create a Date for 23:59:59.999 in Kyiv today, then add 1ms
    const kyivNowStr = `${String(yyyy)}-${String(mm).padStart(2,'0')}-${String(dd).padStart(2,'0')}T00:00:00`;
    // Compute current kyiv offset by comparing Date.parse in that TZ using formatter; fallback to assuming local TZ close enough
    const nowKyivIso = new Intl.DateTimeFormat('en-CA', { timeZone: 'Europe/Kyiv', hour12:false, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit' }).format(now).replace(' ', 'T');
    // Parse kyiv day start in local time by creating a Date from string and adjusting difference between now and kyivNow
    const todayKyivStart = new Date(`${kyivNowStr}.000Z`); // rough
    // Instead of complex TZ math, update countdown using remaining seconds computed from kyiv clock values
    // We'll compute remaining hh:mm:ss until midnight using kyiv clock
    return null; // placeholder not used directly
  }

  function startDailyCountdown(){
    dailyTimerWrap.style.display = 'block';
    if (dailyInterval) clearInterval(dailyInterval);
    dailyInterval = setInterval(() => {
      const now = new Date();
      const parts = new Intl.DateTimeFormat('en-CA', { timeZone: 'Europe/Kyiv', hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit' }).formatToParts(now);
      const get = k => parseInt(parts.find(p=>p.type===k)?.value||'0', 10);
      const hh = get('hour'), mm = get('minute'), ss = get('second');
      const secsToday = hh*3600 + mm*60 + ss;
      const secsInDay = 24*3600;
      let remain = secsInDay - secsToday;
      if (remain <= 0) remain = 0;
      const rh = String(Math.floor(remain/3600)).padStart(2,'0');
      const rm = String(Math.floor((remain%3600)/60)).padStart(2,'0');
      const rs = String(remain%60).padStart(2,'0');
      dailyTimerEl.textContent = `Next word in ${rh}:${rm}:${rs}`;
      const today = toKyivDate(now).iso;
      if (dailySeedDate && today !== dailySeedDate) {
        // rollover
        dailySeedDate = today;
        setupDailyWord();
      }
    }, 500);
  }

  function stopDailyCountdown(){ if (dailyInterval) { clearInterval(dailyInterval); dailyInterval = null; } dailyTimerWrap.style.display = 'none'; }

  function dailyIndex(dateIso){
    // Deterministic index from date string and DICT6 length
    const base = Array.from(dateIso).reduce((a,ch)=> (a*131 + ch.charCodeAt(0))>>>0, 0) ^ 0x9e3779b9;
    if (!window._DICT6_ARR || window._DICT6_ARR.length === 0) return 0;
    return base % window._DICT6_ARR.length;
  }

  function setupDailyWord(){
    if (!dict6Ready) { loadDict6();
      // Try to use a cached word for today to avoid empty banner on refresh
      const todayTry = toKyivDate(new Date()).iso;
      try {
        const cached = localStorage.getItem(`daily_word_${todayTry}`);
        if (cached && /^[A-Z]{6}$/.test(cached)) {
          dailySeedDate = todayTry;
          if (COLS !== 6) { COLS = 6; rebuildBoard(); }
          if (hasPlayedDailyToday(playerNick, todayTry)) {
            lockDailyForToday(cached);
          } else {
            locked = false; finished = false; showPlayfield(); if (dailyResultBox) dailyResultBox.style.display = 'none';
            if (btnHint) { btnHint.removeAttribute('disabled'); btnHint.setAttribute('aria-disabled','false'); }
            resetGame(cached.toLowerCase());
          }
          return; // done via cache
        }
      } catch {}
      // No cache available: use built-in fallback list to ensure we can start now
      if (Array.isArray(FALLBACK6) && FALLBACK6.length) {
        dailySeedDate = todayTry;
        const idx = dailyIndex(todayTry) % FALLBACK6.length;
        const word = FALLBACK6[idx];
        if (word && /^[a-z]{6}$/.test(word)) {
          if (COLS !== 6) { COLS = 6; rebuildBoard(); }
          try { localStorage.setItem(`daily_word_${todayTry}`, String(word).toUpperCase()); } catch {}
          if (hasPlayedDailyToday(playerNick, todayTry)) {
            lockDailyForToday(word);
          } else {
            locked = false; finished = false; showPlayfield(); if (dailyResultBox) dailyResultBox.style.display = 'none';
            if (btnHint) { btnHint.removeAttribute('disabled'); btnHint.setAttribute('aria-disabled','false'); }
            resetGame(word);
          }
          return;
        }
      }
      return; }
    if (!window._DICT6_ARR || window._DICT6_ARR.length !== DICT6.size) window._DICT6_ARR = Array.from(DICT6);
    const today = toKyivDate(new Date()).iso; dailySeedDate = today;
    const idx = dailyIndex(today);
    const word = window._DICT6_ARR[idx];
    if (!word || !/^[a-z]{6}$/.test(word)) { return; }
    // Switch COLS=6 and rebuild if needed
    if (COLS !== 6) { COLS = 6; rebuildBoard(); }
    // Cache today's word (for showing after refresh before dict is ready)
  try { localStorage.setItem(`daily_word_${today}`, String(word).toUpperCase()); } catch {}
    // If already played today, lock and show banner; else start the round
    if (hasPlayedDailyToday(playerNick, today)) {
      lockDailyForToday(word);
    } else {
      // Ensure board and keyboard are visible and unlocked
      locked = false; finished = false; showPlayfield(); if (dailyResultBox) dailyResultBox.style.display = 'none';
      if (btnHint) { btnHint.removeAttribute('disabled'); btnHint.setAttribute('aria-disabled','false'); }
      resetGame(word);
    }
  }

  function enterDaily(){
    mode = MODE_DAILY;
  try { localStorage.setItem('last_mode', MODE_DAILY); } catch {}
    btnDaily.style.display = 'none'; btnNormal.style.display = 'inline-flex';
    // Grid styles
    if (COLS !== 6) { COLS = 6; rebuildBoard(); }
  // Ensure the board is visible and inputs are unlocked immediately
  locked = false; finished = false; showPlayfield();
  if (btnHint) { btnHint.removeAttribute('disabled'); btnHint.setAttribute('aria-disabled','false'); }
  // No restart/next in Daily mode
  btnNew.style.display = 'none';
    // Load dict6 and set today word
    if (!dict6Ready) loadDict6();
  // Set today's word immediately for better UX; handle streak check in background
  setupDailyWord();
  resetDailyStreakIfMissed();
    startDailyCountdown();
  refreshLeaderboard();
  }

  function exitDaily(){
    mode = MODE_NORMAL;
  try { localStorage.setItem('last_mode', MODE_NORMAL); } catch {}
    btnDaily.style.display = 'inline-flex'; btnNormal.style.display = 'none';
    if (COLS !== 5) { COLS = 5; rebuildBoard(); }
    stopDailyCountdown();
  btnNew.textContent = 'Next word'; btnNew.style.display = 'inline-flex';
  // Restore board visibility
  showPlayfield();
  if (dailyResultBox) dailyResultBox.style.display = 'none';
    resetGame();
  refreshLeaderboard();
  }

  btnDaily.addEventListener('click', () => {
    if (!playerNick) { ensureNickname(); return; }
    enterDaily();
  });
  btnNormal.addEventListener('click', () => {
    exitDaily();
  });

  // Game state
  let solution = null;
      let curRow = 0; let curCol = 0; let locked = false; let finished = false;
  let hintCol = -1; let hintChar = '';
  let knownLetters = new Set(); // letters the player has already revealed (yellow or green)
  let knownCorrectPos = new Array(COLS).fill(false); // columns already solved (green)
  const disabledLetters = new Set(); // letters marked absent for this round
      function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
      function pickFromDict(){
        if (mode === MODE_DAILY) {
          if (!dict6Ready) return null;
          if (!window._DICT6_ARR || window._DICT6_ARR.length !== DICT6.size) window._DICT6_ARR = Array.from(DICT6);
          return pick(window._DICT6_ARR);
        } else {
          if (!dictReady) return null;
          if (!window._DICT5_ARR || window._DICT5_ARR.length !== DICT5.size) window._DICT5_ARR = Array.from(DICT5);
          return pick(window._DICT5_ARR);
        }
      }

      // Track if player made at least one submitted guess this round (for forfeit handling)
      const FORFEIT_KEY = 'cookie_wordle_pending_forfeit';
  const FORFEIT_INFO = 'cookie_wordle_forfeit_info';
      let attempted = false;

    function resetGame(newSolution){
  const pickSol = newSolution || pickFromDict();
  if (!pickSol) { showToast('Loading dictionaryâ€¦'); (mode===MODE_DAILY?loadDict6():loadDict)(); return; }
  solution = pickSol; curRow = 0; curCol = 0; locked = false; finished = false; hintCol = -1; hintChar = '';
  knownLetters = new Set(); knownCorrectPos = new Array(COLS).fill(false);
        disabledLetters.clear();
        attempted = false;
        rows.forEach(r => { r.classList.remove('shake','bounce'); });
        tiles.flat().forEach(t => { t.textContent = ''; t.className = 'tile'; t.removeAttribute('data-state'); });
        keyButtons.forEach(b => { b.classList.remove('absent','present','correct'); b.removeAttribute('disabled'); b.removeAttribute('aria-disabled'); b.dataset.state = 'none'; });
        if (btnHint) { btnHint.removeAttribute('disabled'); btnHint.setAttribute('aria-disabled','false'); }
        announce(`New word. Start guessing.`);
      }

    btnNew.addEventListener('click', () => {
        if (locked) return; if (!playerNick) { ensureNickname(); return; }
        // Count as a defeat if at least one row was submitted and the round isn't finished
        if (!finished && attempted) {
      // Clear pending forfeit flags first to avoid duplicate processing on reload
      try { localStorage.removeItem(FORFEIT_KEY); localStorage.removeItem(FORFEIT_INFO); } catch {}
          // If daily mode, update daily leaderboard as a failure for today
          if (mode === MODE_DAILY) {
            // Treat abandon as a loss with max rows
            const todayIso = toKyivDate(new Date()).iso;
            if (dailyProvider && dailyProvider.isSecure && typeof dailyProvider.submitDaily === 'function') dailyProvider.submitDaily(false, ROWS).catch(()=>{});
            else dailyProvider.upsertResult(playerNick, { win: false, attempts: ROWS, dateIso: todayIso }).catch(()=>{});
          } else {
            stats.played++; stats.streak = 0; saveStats(stats); renderStats();
            if (playerNick) {
              if (provider && provider.isSecure && typeof provider.submitNormal === 'function') provider.submitNormal(false).then(refreshLeaderboard).catch(()=>{});
              else provider.upsert(playerNick, { wins: stats.wins, played: stats.played }).then(refreshLeaderboard).catch(()=>{});
            }
          }
        }
        if (mode === MODE_DAILY) {
          // restart same daily word
          const word = solution; resetGame(word);
        } else {
          resetGame();
        }
      });
      btnHint.addEventListener('click', () => {
  if (locked || finished) return;
        if (!playerNick) { ensureNickname(); return; }
        if (hintCol !== -1) { showToast('Hint already used'); return; }
        // In daily mode, keep hint behavior identical
        // Pick a column that is not already solved (green) and whose solution letter hasn't been revealed (no yellow/green yet)
        const candidates = [];
        for (let c=0;c<COLS;c++) {
          const ch = solution[c];
          if (!knownCorrectPos[c] && !knownLetters.has(ch)) candidates.push(c);
        }
        if (candidates.length === 0) { showToast('No new hint available'); return; }
        const col = candidates[Math.floor(Math.random()*candidates.length)];
        hintCol = col; hintChar = solution[col];
  // Fill and lock current and future rows at that column with the revealed char
  for (let r=curRow;r<ROWS;r++) {
          const t = tiles[r][col];
          t.textContent = hintChar.toUpperCase();
          t.classList.add('hint');
          t.setAttribute('data-hint','1');
        }
        // If current cursor was at hint column, move forward
  if (curCol === hintCol) curCol = Math.min(curCol+1, COLS);
  if (btnHint) { btnHint.setAttribute('disabled',''); btnHint.setAttribute('aria-disabled','true'); }
        showToast(`Hint: ${hintChar.toUpperCase()} is in position ${col+1}`);
      });

      function showToast(msg, ms=1200) {
        toastEl.textContent = msg;
        const wide = window.matchMedia('(min-width: 900px)').matches;
        if (wide) {
          const wrap = boardEl.closest('.board-wrap') || boardEl;
          const rect = wrap.getBoundingClientRect();
          const spaceLeft = rect.left;
          const spaceRight = window.innerWidth - rect.right;
          const placeLeft = spaceLeft > spaceRight; // choose side with more space
          toastEl.classList.add('side');
          toastEl.classList.toggle('left', placeLeft);
        } else {
          toastEl.classList.remove('side');
          toastEl.classList.remove('left');
        }
        toastEl.classList.add('show');
        clearTimeout(showToast._t); showToast._t = setTimeout(() => toastEl.classList.remove('show'), ms);
      }
      function announce(msg){ srEl.textContent = msg; }

      function setTile(r,c,ch){ const t = tiles[r][c]; t.textContent = ch.toUpperCase(); t.classList.add('pop'); setTimeout(()=>t.classList.remove('pop'), 100); }
      function clearTile(r,c){ const t = tiles[r][c]; t.textContent=''; }

      function onKey(k){
        // Allow input if not finished and not daily-locked
        if (locked) return;
  if (!playerNick) { ensureNickname(); return; }
        if (finished) return; // wait for Next word
        if (k === 'enter') return submitGuess();
        if (k === 'back') return backspace();
        if (/^[a-z]$/.test(k)) {
          if (disabledLetters.has(k)) return; // don't allow absent letters this round
          if (curCol < COLS) {
            // Skip locked hint column
            if (hintCol !== -1 && curCol === hintCol) curCol++;
            if (curCol < COLS) { setTile(curRow, curCol, k); curCol++; }
          }
        }
      }

      function backspace(){
        if (curCol>0) {
          // If previous is hint column, step back twice
          if (hintCol !== -1 && curCol-1 === hintCol) { curCol -= 2; }
          else { curCol--; }
          if (curCol < 0) { curCol = 0; return; }
          // Avoid clearing hint cell
          if (hintCol !== -1 && curCol === hintCol) return;
          clearTile(curRow, curCol);
        }
      }

      function getGuess(r){ return tiles[r].map(t => (t.textContent||'').toLowerCase()).join(''); }

      async function submitGuess(){
        if (!playerNick) { ensureNickname(); return; }
        // Block input only if they truly played today with a valid nick
        if (mode === MODE_DAILY && isDailyLockedForToday(playerNick)) { showToast('You already played today'); return; }
        const guess = getGuess(curRow);
        if (guess.length < COLS) { rows[curRow].classList.add('shake'); setTimeout(()=>rows[curRow].classList.remove('shake'), 300); showToast('Not enough letters'); return; }
  // Accept only real English words of current mode length
  if (mode === MODE_DAILY) {
    if (!/^[a-z]{6}$/.test(guess)) { rows[curRow].classList.add('shake'); setTimeout(()=>rows[curRow].classList.remove('shake'), 300); showToast('Use 6 letters Aâ€“Z'); return; }
  // Allow any 6-letter guess; just ensure the daily word is ready
    if (!solution || solution.length !== 6) {
      showToast('Loading daily wordâ€¦');
      if (!dict6Ready) loadDict6();
      // Try to compute the word now (in case dict is ready but not yet set)
      setupDailyWord();
      // Wait briefly for the daily solution, then continue or bail
      const ok = await (async ()=>{
        const start = Date.now();
        while (Date.now() - start < 1500) {
          if (solution && solution.length === 6) return true;
          await new Promise(r => setTimeout(r, 100));
        }
        return false;
      })();
      if (!ok) { showToast('Daily word unavailable. Try again.'); return; }
    }
    // Enforce "real word" check: use dict6 if ready; otherwise fallback list
    if (dict6Ready) {
      if (!DICT6.has(guess)) { rows[curRow].classList.add('shake'); setTimeout(()=>rows[curRow].classList.remove('shake'), 300); showToast("We don't accept that"); return; }
    } else if (Array.isArray(FALLBACK6) && FALLBACK6.length) {
      if (!FALLBACK6.includes(guess)) { rows[curRow].classList.add('shake'); setTimeout(()=>rows[curRow].classList.remove('shake'), 300); showToast("We don't accept that"); return; }
    } else {
      showToast('Loading dictionaryâ€¦'); if (!dict6Ready) loadDict6(); return;
    }
  } else {
    if (!/^[a-z]{5}$/.test(guess)) { rows[curRow].classList.add('shake'); setTimeout(()=>rows[curRow].classList.remove('shake'), 300); showToast('Use 5 letters Aâ€“Z'); return; }
    if (!dictReady) { showToast('Loading dictionaryâ€¦'); loadDict(); return; }
    if (!DICT5.has(guess)) { rows[curRow].classList.add('shake'); setTimeout(()=>rows[curRow].classList.remove('shake'), 300); showToast("We don't accept that"); return; }
  }
        // Enforce hint position if used
        if (hintCol !== -1 && guess[hintCol] !== hintChar) { rows[curRow].classList.add('shake'); setTimeout(()=>rows[curRow].classList.remove('shake'), 300); showToast(`The ${hintCol+1}áµ—Ê° letter must be ${hintChar.toUpperCase()}`); return; }
  // First valid submission in this round: mark attempt and set pending-forfeit flag in case of refresh/skip
  if (!attempted) {
    attempted = true;
    try { if (!localStorage.getItem(FORFEIT_KEY)) localStorage.setItem(FORFEIT_KEY, '1'); } catch {}
  }
  // Update forfeit meta with most recent submitted row count and mode
  try {
    const todayIso = mode===MODE_DAILY ? toKyivDate(new Date()).iso : null;
    localStorage.setItem(FORFEIT_INFO, JSON.stringify({ mode, attempts: (curRow+1), dateIso: todayIso }));
  } catch {}
        revealRow(guess);
      }

      function computeResult(guess, answer){
        // Wordle letter eval with duplicates
        const res = new Array(COLS).fill('absent');
        const counts = new Map();
        for (let i=0;i<COLS;i++) { const a = answer[i]; counts.set(a, (counts.get(a)||0)+1); }
        // First pass: correct
        for (let i=0;i<COLS;i++) {
          if (guess[i] === answer[i]) { res[i] = 'correct'; counts.set(guess[i], counts.get(guess[i]) - 1); }
  }
        // Second pass: present
        for (let i=0;i<COLS;i++) {
          if (res[i] === 'correct') continue;
          const g = guess[i];
          if ((counts.get(g)||0) > 0) { res[i] = 'present'; counts.set(g, counts.get(g)-1); }
        }
        return res;
      }

      function updateKeyboard(guess, result){
        const rank = { none: -1, absent: 0, present: 1, correct: 2 };
        for (let i=0;i<COLS;i++){
          const ch = guess[i]; const b = keyButtons.get(ch); if (!b) continue;
          const r = result[i];
          const cur = b.dataset.state || 'none';
          if (rank[r] > rank[cur]) {
            b.dataset.state = r;
            b.classList.remove('absent','present','correct');
            b.classList.add(r);
          }
          // Disable absent letters for the rest of the round; re-enable if later upgraded
          const state = b.dataset.state;
          if (state === 'absent') { b.setAttribute('disabled',''); b.setAttribute('aria-disabled','true'); disabledLetters.add(ch); }
          else if (state === 'present' || state === 'correct') { b.removeAttribute('disabled'); b.removeAttribute('aria-disabled'); disabledLetters.delete(ch); }
        }
      }

      function revealRow(guess){
        locked = true;
  const res = computeResult(guess, solution);
  const rowTiles = tiles[curRow];
  // Remove hint highlight from the row being revealed so state colors show clearly
  rowTiles.forEach(t => t.classList.remove('hint'));
        rowTiles.forEach(t => t.classList.add('revealed'));
        // flip each with delay
        res.forEach((state, i) => {
          setTimeout(() => {
            const t = rowTiles[i];
            t.classList.add('flip');
            setTimeout(() => {
              t.classList.remove('flip');
              t.classList.add(state);
              t.setAttribute('data-state', state);
              if (i === COLS-1) { // last
                updateKeyboard(guess, res);
                afterReveal(guess, res);
              }
            }, 300);
          }, i * 260);
        });
      }

      function afterReveal(guess, res){
        // Update knowledge from this row's result
        for (let i=0;i<COLS;i++) {
          if (res[i] === 'correct') { knownCorrectPos[i] = true; knownLetters.add(guess[i]); }
          else if (res[i] === 'present') { knownLetters.add(guess[i]); }
        }
        const win = res.every(s => s === 'correct');
        if (win) {
          rows[curRow].classList.add('bounce');
          finished = true; locked = false;
          // Only update normal stats/leaderboard in Normal mode
          if (mode === MODE_NORMAL) {
            stats.played++; stats.wins++; stats.streak++; stats.maxStreak = Math.max(stats.maxStreak, stats.streak); saveStats(stats); renderStats();
            if (playerNick) {
              if (provider && provider.isSecure && typeof provider.submitNormal === 'function') provider.submitNormal(true).then(refreshLeaderboard).catch(()=>{});
              else provider.upsert(playerNick, { wins: stats.wins, played: stats.played }).then(refreshLeaderboard).catch(()=>{});
            }
          }
          // Clear any pending forfeit (round concluded)
          localStorage.removeItem(FORFEIT_KEY); localStorage.removeItem(FORFEIT_INFO);
          if (mode === MODE_DAILY && playerNick) {
            const todayIso = toKyivDate(new Date()).iso;
            const attempts = curRow + 1; // rows used to win
            (dailyProvider && dailyProvider.isSecure && typeof dailyProvider.submitDaily === 'function' ? dailyProvider.submitDaily(true, attempts) : dailyProvider.upsertResult(playerNick, { win: true, attempts, dateIso: todayIso })).then(()=>{
              setDailyPlayedToday(playerNick, todayIso);
              lockDailyForToday(solution);
              refreshLeaderboard();
            }).catch(()=>{ setDailyPlayedToday(playerNick, todayIso); lockDailyForToday(solution); });
          }
          showToast(['Nice!','Clean!','Sharp!','Neon!'][Math.floor(Math.random()*4)], 1400);
          announce('You guessed it!');
          return;
  }

        curRow++; curCol = 0; locked = false;
        // If hint is active, prefill the next row's hint cell and place cursor after it
        if (!finished && hintCol !== -1 && curRow < ROWS) {
          const t = tiles[curRow][hintCol];
          t.textContent = hintChar.toUpperCase();
          t.classList.add('hint'); t.setAttribute('data-hint','1');
          // Place cursor at the first editable cell (leftmost non-hint column)
          curCol = hintCol === 0 ? 1 : 0;
        }
        if (curRow >= ROWS) {
          finished = true;
          if (mode === MODE_NORMAL) { stats.played++; stats.streak = 0; saveStats(stats); renderStats(); }
          // push leaderboard totals (loss) only in Normal mode
          if (mode === MODE_NORMAL && playerNick) {
            if (provider && provider.isSecure && typeof provider.submitNormal === 'function') provider.submitNormal(false).then(refreshLeaderboard).catch(()=>{});
            else provider.upsert(playerNick, { wins: stats.wins, played: stats.played }).then(refreshLeaderboard).catch(()=>{});
          }
          // Clear any pending forfeit (round concluded)
          localStorage.removeItem(FORFEIT_KEY); localStorage.removeItem(FORFEIT_INFO);
          if (mode === MODE_DAILY && playerNick) {
            const todayIso = toKyivDate(new Date()).iso;
            (dailyProvider && dailyProvider.isSecure && typeof dailyProvider.submitDaily === 'function' ? dailyProvider.submitDaily(false, ROWS) : dailyProvider.upsertResult(playerNick, { win: false, attempts: ROWS, dateIso: todayIso })).finally(()=>{
              setDailyPlayedToday(playerNick, todayIso);
              lockDailyForToday(solution);
              refreshLeaderboard();
            });
          }
          showToast(`The word was "${solution.toUpperCase()}"`, 1800);
          announce(`Game over. The word was ${solution}.`);
        }
      }

      // Physical keyboard
      window.addEventListener('keydown', (e) => {
        // Ignore global key handling when a modal is open or typing in inputs
        if (modalNick.classList.contains('show') || modalLeader.classList.contains('show')) return;
        const tag = (e.target && e.target.tagName || '').toLowerCase();
        if (tag === 'input' || tag === 'textarea' || (e.target && e.target.isContentEditable)) return;
        const k = e.key.toLowerCase();
        if (k === 'enter') onKey('enter');
        else if (k === 'backspace' || k === 'delete') onKey('back');
        else if (k.length === 1 && k >= 'a' && k <= 'z') onKey(k);
      });

      // Helper: small seed of solved word in console for testing (comment out in prod)
      // console.log('Solution:', solution);

  // On load: if a previous round was abandoned after at least one submission, count it as a defeat
  (function handlePendingForfeitOnLoad(){
    try {
      if (localStorage.getItem(FORFEIT_KEY)) {
        // Clear first to ensure we don't double-count if any code path below reloads UI or errors
        try { localStorage.removeItem(FORFEIT_KEY); } catch {}
        // If the pending forfeit was from daily mode, mark a failure for today; else treat as normal loss
        let handledDaily = false;
        try {
          const meta = JSON.parse(localStorage.getItem(FORFEIT_INFO)||'null');
          if (meta && meta.mode === MODE_DAILY) {
            const todayIso = toKyivDate(new Date()).iso;
            const dateIso = meta.dateIso || todayIso;
            if (playerNick) {
              if (dailyProvider && dailyProvider.isSecure && typeof dailyProvider.submitDaily === 'function') dailyProvider.submitDaily(false, ROWS).catch(()=>{});
              else dailyProvider.upsertResult(playerNick, { win: false, attempts: ROWS, dateIso }).catch(()=>{});
              setDailyPlayedToday(playerNick, dateIso);
            }
            // Only show today's banner immediately if already in Daily mode and the forfeit is for today
            if (mode === MODE_DAILY && dateIso === todayIso) {
              try {
                const cached = localStorage.getItem(`daily_word_${todayIso}`);
                if (cached) { lockDailyForToday(cached); }
              } catch {}
            }
            handledDaily = true;
          }
        } catch {}
  if (!handledDaily) {
          stats.played++; stats.streak = 0; saveStats(stats); renderStats();
          if (playerNick) {
            if (provider && provider.isSecure && typeof provider.submitNormal === 'function') provider.submitNormal(false).then(refreshLeaderboard).catch(()=>{});
            else provider.upsert(playerNick, { wins: stats.wins, played: stats.played }).then(refreshLeaderboard).catch(()=>{});
          }
        }
  try { localStorage.removeItem(FORFEIT_INFO); } catch {}
      }
    } catch {}
  })();

  async function resetDailyStreakIfMissed(){
    if (!playerNick) return;
    try {
      const rec = await dailyProvider.get(playerNick);
      if (!rec || !rec.last_played) return;
      const today = toKyivDate(new Date()).iso;
      const y = new Date(Date.now() - 24*3600*1000);
      const yesterday = toKyivDate(y).iso;
      const last = rec.last_played;
      if (last !== today && last !== yesterday) {
        // Missed at least one day; reset streak to 0 without changing last_played
        if (typeof dailyProvider.upsertRow === 'function') {
          await dailyProvider.upsertRow({ nick: playerNick, streak: 0, today_rows: rec.today_rows ?? null, last_played: last });
        } else {
          await dailyProvider.upsertResult(playerNick, { win: false, attempts: rec.today_rows ?? 6, dateIso: last });
        }
      }
    } catch {}
  }

  // --- Daily one-attempt-per-day helpers and UI lock ---
  function dailyStatusKey(nick){ return `daily_status_${(nick||'').toLowerCase()}`; }
  function setDailyPlayedToday(nick, dateIso){ try { localStorage.setItem(dailyStatusKey(nick), JSON.stringify({ dateIso })); } catch {} }
  function getDailyStatus(nick){ try { return JSON.parse(localStorage.getItem(dailyStatusKey(nick))||'null'); } catch { return null; } }
  function hasPlayedDailyToday(nick, todayIso){ const s = getDailyStatus(nick); return !!(s && s.dateIso === todayIso); }
  function isDailyLockedForToday(nick){
    const today = toKyivDate(new Date()).iso;
    if (!nick || !nick.trim()) return false;
    return hasPlayedDailyToday(nick, today);
  }
  function lockDailyForToday(word){
    // Hide board grid and disable keyboard, show result banner
  hidePlayfield();
    if (dailyResultBox && dailyResultText) {
      let shown = String(word||'').toUpperCase();
      if (!shown) {
        try {
          const today = toKyivDate(new Date()).iso;
          const cached = localStorage.getItem(`daily_word_${today}`);
          if (cached) shown = cached;
        } catch {}
      }
      dailyResultText.textContent = `The word of the day was: ${shown}`;
      dailyResultBox.style.display = 'block';
    }
    locked = true; finished = true;
    if (btnHint) { btnHint.setAttribute('disabled',''); btnHint.setAttribute('aria-disabled','true'); }
  }

  // Visibility helpers
  function showPlayfield(){
    if (boardEl) boardEl.style.display = '';
    if (keyboardWrap) { keyboardWrap.style.pointerEvents = ''; keyboardWrap.style.display = ''; }
    if (btnHint) { btnHint.removeAttribute('disabled'); btnHint.setAttribute('aria-disabled','false'); }
  }
  function hidePlayfield(){
    if (boardEl) boardEl.style.display = 'none';
    if (keyboardWrap) { keyboardWrap.style.pointerEvents = 'none'; keyboardWrap.style.display = 'none'; }
    if (btnHint) { btnHint.setAttribute('disabled',''); btnHint.setAttribute('aria-disabled','true'); }
  }

  // Nickname badge render helper
  function renderNickBadge(){ if (nickFooter) nickFooter.textContent = playerNick ? playerNick : 'Guest'; }
  renderNickBadge();

  // Start: enforce nickname, then restore last mode and start game
  ensureNickname().then(()=>{
    if (!playerNick) return;
    let last = null; try { last = localStorage.getItem('last_mode'); } catch {}
    if (last === MODE_DAILY) { enterDaily(); }
    else { showPlayfield(); resetGame(); }
  });
    </script>
  </body>
</html>
