<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neon Wordle — Unlimited</title>
    <style>
      :root {
        --bg0: #0a0b0f;
        --bg1: #0e1018;
        --panel: #141724;
        --panel-2: #121523;
        --text: #e6e7ee;
        --muted: #9aa0b4;
        --key-text: #e6e7ee;
        --tile-text: #f5f7ff;
        --absent: #3f4458;
        --present: #ffdc5e;
        --correct: #2ee865;
        --accent: #00e5ff;
        --accent-2: #ff38c7;
        --toast-bg: rgba(10, 12, 20, 0.9);
        --white: #fff;
        --boardW: 520px; /* used to place side toast */
        --glow: 0 0 12px rgba(0,229,255,0.45), 0 0 32px rgba(0,229,255,0.25);
        --glow-mag: 0 0 12px rgba(255,56,199,0.45), 0 0 32px rgba(255,56,199,0.25);
  --gap: 8px; /* board/key spacing */
      }
      
  /* Prevent padding from causing overflow and right-side gaps */
  *, *::before, *::after { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--text);
        background:
          radial-gradient(1000px 800px at 10% 10%, rgba(0,229,255,0.12), transparent 60%),
          radial-gradient(900px 700px at 80% 20%, rgba(255,56,199,0.10), transparent 60%),
          linear-gradient(180deg, var(--bg1), var(--bg0));
        background-attachment: fixed;
        overflow-x: hidden;
      }
  /* Improve touch feel on mobile */
  * { -webkit-tap-highlight-color: rgba(0,0,0,0); }

      /* subtle cookie speckles */
      body::before {
        content: '';
        position: fixed; inset: 0;
        pointer-events: none;
        background:
          radial-gradient(400px 400px at 20% 80%, rgba(0,229,255,0.08), transparent 70%),
          radial-gradient(350px 350px at 80% 70%, rgba(255,56,199,0.08), transparent 70%);
        mix-blend-mode: screen;
      }

  /* no cookie crisps in neon theme */

  header { position: sticky; top: 0; z-index: 5; background: linear-gradient(180deg, rgba(10,12,20,0.8), rgba(10,12,20,0.5)); backdrop-filter: blur(6px); border-bottom: 1px solid rgba(0,229,255,0.2); }
  .header-inner { width: 100%; max-width: 760px; margin: 0 auto; padding: 12px 16px; display: flex; align-items: center; justify-content: space-between; gap: 12px; }
  .brand { display: flex; align-items: center; gap: 10px; font-weight: 800; letter-spacing: 1px; color: var(--text); }
  .brand .cookie { width: 28px; height: 28px; border-radius: 50%; background: radial-gradient(16px 16px at 35% 35%, var(--accent) 0, rgba(0,229,255,0.15) 60%, transparent 70%), radial-gradient(10px 10px at 70% 60%, var(--accent-2) 0, rgba(255,56,199,0.12) 60%, transparent 70%); box-shadow: var(--glow), var(--glow-mag); }
  .brand span { font-size: 18px; color: var(--text); }

      .stats {
        display: flex; gap: 10px; align-items: center; font-size: 12px; opacity: 0.9;
      }
  .stat { background: rgba(20,23,36,0.8); border: 1px solid rgba(0,229,255,0.2); border-radius: 10px; padding: 6px 10px; min-width: 52px; text-align: center; box-shadow: 0 0 10px rgba(0,229,255,0.15) inset; color: var(--muted); }
      .controls { display: flex; gap: 8px; align-items: center; }
  .btn { appearance: none; border: 1px solid rgba(0,229,255,0.35); background: linear-gradient(180deg, #1a1f33, #12172a); color: var(--text); border-radius: 10px; padding: 8px 12px; font-weight: 700; box-shadow: var(--glow); cursor: pointer; }
      .btn:active { transform: translateY(1px); }

      main { max-width: 1040px; margin: 16px auto; padding: 0 16px calc(28px + env(safe-area-inset-bottom, 0px)); }

      /* Layout with optional left sidebar (leaderboard) */
  .layout { display: grid; grid-template-columns: 1fr; gap: 16px; align-items: start; }
      .sidebar { display: none; background: linear-gradient(180deg, var(--panel), var(--panel-2)); border-radius: 16px; border: 1px solid rgba(0,229,255,0.25); box-shadow: 0 12px 28px rgba(0,0,0,0.35), inset 0 0 18px rgba(0,229,255,0.08); padding: 12px; }
      .sidebar h3 { margin: 6px 8px 10px; font-size: 14px; font-weight: 800; letter-spacing: .5px; color: var(--text); }
      .leader-scroll { max-height: 520px; overflow: auto; border-radius: 10px; border: 1px solid rgba(0,229,255,0.18); }
      table.leader { width: 100%; border-collapse: collapse; font-size: 13px; }
      .leader thead th { position: sticky; top: 0; background: #12172a; color: var(--muted); text-align: left; padding: 8px 10px; border-bottom: 1px solid rgba(0,229,255,0.18); }
      .leader tbody td { padding: 8px 10px; border-bottom: 1px solid rgba(0,229,255,0.1); }
      .leader tbody tr:hover { background: rgba(0,229,255,0.05); }
      .leader .col-r { text-align: right; }

      /* Leaderboard button visibility: show on small screens, hide when sidebar is visible */
      #btn-leader { display: inline-flex; }
      @media (min-width: 980px) {
        .sidebar { display: block; }
        #btn-leader { display: none; }
        .layout { grid-template-columns: 340px 1fr; }
      }

  .board-wrap { background: linear-gradient(180deg, var(--panel), var(--panel-2)); border-radius: 16px; border: 1px solid rgba(0,229,255,0.25); box-shadow: 0 12px 28px rgba(0,0,0,0.35), inset 0 0 18px rgba(0,229,255,0.08); padding: 16px; margin: 0 auto 16px; width: 100%; max-width: var(--boardW); }
      .board {
        display: grid; grid-template-rows: repeat(6, 1fr); gap: var(--gap);
        width: 100%; max-width: 480px; aspect-ratio: 5/6; margin: 0 auto;
      }
      .row { display: grid; grid-template-columns: repeat(5, 1fr); gap: var(--gap); }

  .tile { position: relative; display: grid; place-items: center; font-weight: 800; font-size: clamp(18px, 7vw, 28px); color: var(--tile-text); background: linear-gradient(180deg, #1a1f33, #111526); border: 2px solid rgba(0,229,255,0.25); border-radius: 12px; box-shadow: inset 0 0 10px rgba(0,229,255,0.08); text-transform: uppercase; transform-style: preserve-3d; transition: transform 0.3s ease, border-color .2s ease, box-shadow .2s ease; }

      .tile.revealed { transition: transform 0.6s cubic-bezier(.2,.7,.2,1); }
      .tile.flip { transform: rotateX(90deg); }

  .tile.absent { background: #252a3a; color: var(--white); border-color: #394058; }
  .tile.present { background: #554400; color: #ffe57a; border-color: #ffdc5e; box-shadow: 0 0 10px rgba(255,220,94,0.35); }
  .tile.correct { background: #003d22; color: #a6ffd0; border-color: var(--correct); box-shadow: 0 0 12px rgba(46,232,101,0.45); }
  .tile.hint { border-color: var(--accent); box-shadow: 0 0 12px rgba(0,229,255,0.55); }

      .tile.pop { animation: pop 100ms ease-out; }
      @keyframes pop { 0% { transform: scale(0.9); } 100% { transform: scale(1); } }
      .row.shake { animation: shake 300ms ease-in-out; }
      @keyframes shake { 10%, 90% { transform: translateX(-2px); } 20%, 80% { transform: translateX(3px); } 30%, 50%, 70% { transform: translateX(-5px); } 40%, 60% { transform: translateX(5px);} }
      .row.bounce { animation: bounce 600ms ease-in-out; }
      @keyframes bounce { 0%, 100% { transform: translateY(0); } 30% { transform: translateY(-6px); } }

  .keyboard { width: 100%; max-width: 520px; margin: 0 auto; display: grid; gap: var(--gap); }
  .key-row { display: grid; grid-auto-flow: column; grid-auto-columns: 1fr; gap: var(--gap); }
  .key { user-select: none; cursor: pointer; text-transform: uppercase; font-weight: 700; font-size: clamp(12px, 3.5vw, 14px); padding: clamp(8px, 2.4vw, 12px) 6px; text-align: center; border-radius: 10px; color: var(--key-text); background: linear-gradient(180deg, #1a1f33, #12172a); border: 2px solid rgba(0,229,255,0.25); box-shadow: inset 0 0 10px rgba(0,229,255,0.08); }
      .key:active { transform: translateY(1px); }
  .key.absent { background: #252a3a; color: var(--white); border-color: #394058; }
  .key.present { background: #554400; color: #ffe57a; border-color: #ffdc5e; box-shadow: 0 0 10px rgba(255,220,94,0.35) inset; }
  .key.correct { background: #003d22; color: #a6ffd0; border-color: var(--correct); box-shadow: 0 0 12px rgba(46,232,101,0.45) inset; }
      .key.wide { grid-column: span 1; font-size: 12px; }
      .key.backspace { font-size: 12px; }
      .key[disabled] {
        pointer-events: none;
        opacity: 0.6;
        filter: grayscale(25%);
        cursor: not-allowed;
      }

  .toast { position: fixed; top: 18px; left: 50%; transform: translateX(-50%); background: var(--toast-bg); color: #e6f7ff; padding: 10px 12px; border-radius: 10px; font-weight: 700; box-shadow: 0 0 18px rgba(0,229,255,0.4); opacity: 0; pointer-events: none; transition: opacity .2s ease, transform .2s ease; z-index: 10000; }
      .toast.show { opacity: 1; transform: translate(-50%, 4px); }

      /* Side placement relative to centered board */
      @media (min-width: 900px) {
        .toast.side { top: 110px; left: 50%; transform: translateX(calc(var(--boardW) / 2 + 44px)); }
        .toast.side.show { transform: translate(calc(var(--boardW) / 2 + 44px), 4px); }
        .toast.side.left { transform: translateX(calc(-1 * (var(--boardW) / 2 + 44px))); }
        .toast.side.left.show { transform: translate(calc(-1 * (var(--boardW) / 2 + 44px)), 4px); }
      }

      /* Mobile optimizations */
      @media (max-width: 480px) {
        .header-inner { padding: 10px 12px; }
        .btn { padding: 6px 10px; }
        .board-wrap { padding: 12px; border-radius: 12px; }
        :root { --gap: 6px; }
  .header-inner { flex-wrap: wrap; gap: 8px; }
  .controls { flex-wrap: wrap; gap: 6px; }
  .stats { flex-wrap: wrap; gap: 6px; }
  .stat { padding: 4px 8px; min-width: auto; font-size: 11px; }
  .brand span { font-size: 16px; }
      }
      @media (max-width: 360px) {
        :root { --gap: 4px; }
        .board-wrap { padding: 10px; }
  .brand span { font-size: 15px; }
  .stat { font-size: 10px; }
      }

      .sr-only { position: absolute; left: -10000px; top: auto; width: 1px; height: 1px; overflow: hidden; }

  /* Modal base styles (for nickname and mobile leaderboard) */
  .modal-backdrop { position: fixed; inset: 0; background: rgba(6,8,14,0.7); backdrop-filter: blur(4px); display: none; align-items: center; justify-content: center; z-index: 10001; }
  .modal-backdrop.show { display: flex; }
  .modal-card { width: min(92vw, 520px); background: linear-gradient(180deg, #1a1f33, #12172a); border: 1px solid rgba(0,229,255,0.3); border-radius: 14px; box-shadow: var(--glow); color: var(--text); }
  .modal-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 14px; border-bottom: 1px solid rgba(0,229,255,0.18); }
  .modal-title { font-weight: 800; letter-spacing: .6px; }
  .modal-body { padding: 14px; }
  .modal-footer { padding: 12px 14px; display: flex; align-items: center; justify-content: flex-end; gap: 8px; border-top: 1px solid rgba(0,229,255,0.18); }
  .input { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(0,229,255,0.25); background: #0f1324; color: var(--text); font-weight: 700; letter-spacing: .4px; }
  .help { color: var(--muted); font-size: 12px; margin-top: 6px; }
  .error { color: #ff6b8a; font-size: 12px; margin-top: 6px; font-weight: 700; }
    </style>
  </head>
  <body>
    <header>
      <div class="header-inner">
        <div class="brand">
          <div class="cookie" aria-hidden="true"></div>
          <span>Neon Wordle</span>
        </div>
        <div class="controls">
          <div class="stats">
            <div class="stat" title="Games played">GP <span id="stat-played">0</span></div>
            <div class="stat" title="Win %">W% <span id="stat-win">0</span></div>
            <div class="stat" title="Current streak">CS <span id="stat-streak">0</span></div>
            <div class="stat" title="Max streak">MS <span id="stat-max">0</span></div>
          </div>
          <button id="btn-hint" class="btn" aria-label="Reveal a letter hint">Hint</button>
          <button id="btn-new" class="btn" aria-label="Start next word">Next word</button>
          <button id="btn-leader" class="btn" aria-haspopup="dialog" aria-controls="modal-leader" title="Show leaderboards">Leaderboards</button>
          <button id="btn-change-nick" class="btn" title="Change your nickname">Change Nickname</button>
        </div>
      </div>
    </header>

    <main>
      <div class="layout">
        <aside id="sidebar" class="sidebar" aria-label="Global Leaderboard">
          <h3>Global Leaderboard</h3>
          <div class="leader-scroll">
            <table class="leader" aria-describedby="leader-desc">
              <thead>
                <tr><th>Nickname</th><th class="col-r">Total Guessed</th><th class="col-r">Win %</th></tr>
              </thead>
              <tbody id="leader-tbody"><tr><td colspan="3" style="padding:10px 12px;color:var(--muted)">Loading…</td></tr></tbody>
            </table>
          </div>
          <div id="leader-desc" class="sr-only">Sorted by total words guessed descending. Scroll if long.</div>
        </aside>
        <section>
          <div class="board-wrap">
  <div id="board" class="board" role="application" aria-label="Neon Wordle board">
          <!-- rows/tiles injected -->
        </div>
          </div>
          <div class="keyboard" aria-label="On-screen keyboard">
            <div class="key-row" id="kb-row-1"></div>
            <div class="key-row" id="kb-row-2"></div>
            <div class="key-row" id="kb-row-3"></div>
          </div>
        </section>
      </div>
    </main>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>
    <div class="sr-only" aria-live="polite" id="sr"></div>

    <!-- Nickname Modal -->
    <div id="modal-nick" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="nick-title">
      <div class="modal-card">
        <div class="modal-header">
          <div id="nick-title" class="modal-title">Choose your nickname</div>
        </div>
        <div class="modal-body">
          <label for="nick-input" style="display:block; font-weight:700; margin-bottom:6px;">Nickname</label>
          <input id="nick-input" class="input" maxlength="12" placeholder="letters and digits only" autocomplete="off" />
          <div class="help">Required to play. 1–12 chars, A–Z and 0–9 only. Unique globally.</div>
          <div id="nick-error" class="error" role="alert" style="display:none"></div>
        </div>
        <div class="modal-footer">
          <button id="nick-confirm" class="btn">Save</button>
        </div>
      </div>
    </div>

    <!-- Leaderboard Modal (mobile) -->
    <div id="modal-leader" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="leader-title">
      <div class="modal-card" style="width:min(96vw,700px)">
        <div class="modal-header">
          <div id="leader-title" class="modal-title">Global Leaderboard</div>
          <button id="leader-close" class="btn" aria-label="Close">Close</button>
        </div>
        <div class="modal-body">
          <div class="leader-scroll" style="max-height:60vh">
            <table class="leader">
              <thead>
                <tr><th>Nickname</th><th class="col-r">Total Guessed</th><th class="col-r">Win %</th></tr>
              </thead>
              <tbody id="leader-tbody-modal"><tr><td colspan="3" style="padding:10px 12px;color:var(--muted)">Loading…</td></tr></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

  <!-- Removed embedded word bank: now selecting solutions from dict5.txt only -->

  <script>
    // Global leaderboard: Supabase config (public anon key)
    window.LEADERBOARD_API = {
      type: 'supabase',
      url: 'https://jmcjlvukbuqsickepjbp.supabase.co',
      key: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImptY2psdnVrYnVxc2lja2VwamJwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUwOTMyOTUsImV4cCI6MjA3MDY2OTI5NX0.g-PoNyO_c9NFZMqPA8zM5LfhUuCzGY9UCYYvY5h8vIc',
      schema: 'public',
      table: 'players'
    };
  </script>


    <script>
      // Dictionary of acceptable English 5-letter words (fetched from dict5.txt)
      const DICT5 = new Set();
      let dictReady = false; let dictLoading = false;
      function loadDict(){
        if (dictReady || dictLoading) return;
        dictLoading = true;
        fetch('dict5.txt', { cache: 'no-store' })
          .then(r => r.ok ? r.text() : Promise.reject(r.status))
          .then(txt => {
            txt.split(/\r?\n/).forEach(w => { const s=w.trim(); if (s) DICT5.add(s); });
            dictReady = DICT5.size > 0;
            if (dictReady) { window._DICT5_ARR = Array.from(DICT5); }
            // If user is ready to play but we had no solution yet, start a round now
            if (dictReady && playerNick && !solution) { resetGame(); }
          })
          .catch(() => { dictReady = false; })
          .finally(() => { dictLoading = false; });
      }
      loadDict();

      // --- Leaderboard and nickname gating ---
      const btnLeader = document.getElementById('btn-leader');
  const btnChangeNick = document.getElementById('btn-change-nick');
      const sidebarEl = document.getElementById('sidebar');
      const leaderBody = document.getElementById('leader-tbody');
      const leaderBodyModal = document.getElementById('leader-tbody-modal');
      const modalNick = document.getElementById('modal-nick');
      const nickInput = document.getElementById('nick-input');
      const nickConfirm = document.getElementById('nick-confirm');
      const nickError = document.getElementById('nick-error');
      const modalLeader = document.getElementById('modal-leader');
      const leaderClose = document.getElementById('leader-close');

      function openModal(m){ m.classList.add('show'); }
      function closeModal(m){ m.classList.remove('show'); }
      function sanitize(text){
        const map = { '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#39;' };
        return String(text).replace(/[&<>"']/g, ch => map[ch]);
      }

      // Provider abstraction; default Local fallback. To enable global sync, set window.LEADERBOARD_API with endpoints.
      class LocalLeaderboard {
        constructor(){
          this.key = 'leader_local_players';
          this.map = this._load();
        }
        _load(){ try { return new Map(Object.entries(JSON.parse(localStorage.getItem(this.key)||'{}'))); } catch { return new Map(); } }
        _save(){ const obj = Object.fromEntries(this.map); localStorage.setItem(this.key, JSON.stringify(obj)); }
        async exists(nick){ return this.map.has(nick.toLowerCase()); }
        async register(nick){ const k = nick.toLowerCase(); if (this.map.has(k)) throw new Error('exists'); this.map.set(k, { nick, wins: 0, played: 0 }); this._save(); return true; }
        async upsert(nick, totals){ const k = nick.toLowerCase(); const cur = this.map.get(k) || { nick, wins: 0, played: 0 }; this.map.set(k, { nick, wins: Math.max(totals.wins, cur.wins), played: Math.max(totals.played, cur.played) }); this._save(); return true; }
        async delete(nick){ const k = nick.toLowerCase(); this.map.delete(k); this._save(); return true; }
        async list(){ return Array.from(this.map.values()); }
      }

      // Optional remote REST provider. Set window.LEADERBOARD_API = { baseUrl: 'https://your.api', apiKey: 'optional' }.
      class RemoteLeaderboard {
        constructor(cfg){ this.cfg = cfg; }
        async _fetch(path, opts={}){
          const headers = Object.assign({ 'Content-Type': 'application/json' }, this.cfg.apiKey ? { 'Authorization': `Bearer ${this.cfg.apiKey}` } : {});
          const res = await fetch(`${this.cfg.baseUrl}${path}`, { ...opts, headers });
          if (!res.ok) throw new Error(`http ${res.status}`);
          return res.json();
        }
        async exists(nick){ const j = await this._fetch(`/players/exists?nick=${encodeURIComponent(nick)}`); return !!j.exists; }
        async register(nick){ const j = await this._fetch(`/players`, { method:'POST', body: JSON.stringify({ nick }) }); if (j && j.error) throw new Error(j.error); return true; }
        async upsert(nick, totals){ const j = await this._fetch(`/players/${encodeURIComponent(nick)}`, { method:'PUT', body: JSON.stringify(totals) }); if (j && j.error) throw new Error(j.error); return true; }
        async delete(nick){ await this._fetch(`/players/${encodeURIComponent(nick)}`, { method: 'DELETE' }); return true; }
        async list(){ return this._fetch(`/players`); }
      }

      // Supabase REST provider
      // window.LEADERBOARD_API example:
      // { type: 'supabase', url: 'https://PROJECT.supabase.co', key: 'ANON_KEY', schema: 'public', table: 'players' }
      class SupabaseLeaderboard {
        constructor(cfg){
          this.url = cfg.url.replace(/\/$/, '');
          this.key = cfg.key;
          this.schema = cfg.schema || 'public';
          this.table = cfg.table || 'players';
        }
        _headers(extra={}){
          return Object.assign({
            'apikey': this.key,
            'Authorization': `Bearer ${this.key}`,
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Prefer': 'return=minimal'
          }, extra);
        }
        async exists(nick){
          const res = await fetch(`${this.url}/rest/v1/${this.table}?select=nick&nick=eq.${encodeURIComponent(nick)}`, { headers: this._headers() });
          if (!res.ok) throw new Error(`http ${res.status}`);
          const arr = await res.json();
          return Array.isArray(arr) && arr.length > 0;
        }
        async register(nick){
          const body = JSON.stringify({ nick, wins: 0, played: 0 });
          const res = await fetch(`${this.url}/rest/v1/${this.table}`, { method: 'POST', headers: this._headers({ 'Prefer': 'return=representation' }), body });
          if (res.status === 409) throw new Error('exists');
          if (!res.ok) throw new Error(`http ${res.status}`);
          return true;
        }
        async upsert(nick, totals){
          // Upsert via POST with merge duplicates (requires unique index on nick)
          const body = JSON.stringify({ nick, wins: totals.wins|0, played: totals.played|0 });
          const headers = this._headers({ 'Prefer': 'resolution=merge-duplicates,return=minimal' });
          const res = await fetch(`${this.url}/rest/v1/${this.table}`, { method: 'POST', headers, body });
          if (!res.ok && res.status !== 409) throw new Error(`http ${res.status}`);
          return true;
        }
        async delete(nick){
          const res = await fetch(`${this.url}/rest/v1/${this.table}?nick=eq.${encodeURIComponent(nick)}`, { method: 'DELETE', headers: this._headers({ 'Prefer': 'return=minimal' }) });
          if (!res.ok) throw new Error(`http ${res.status}`);
          return true;
        }
        async list(){
          const res = await fetch(`${this.url}/rest/v1/${this.table}?select=nick,wins,played`, { headers: this._headers() });
          if (!res.ok) throw new Error(`http ${res.status}`);
          return res.json();
        }
      }

  let provider = null;
  const LB = window.LEADERBOARD_API || null;
  if (LB && LB.type === 'supabase' && LB.url && LB.key) provider = new SupabaseLeaderboard(LB);
  else if (LB && LB.baseUrl) provider = new RemoteLeaderboard(LB);
  else provider = new LocalLeaderboard();
      let playerNick = (localStorage.getItem('player_nick')||'').trim();
      let canPlay = false;
      let pendingOldNick = null; // when renaming, delete this after new nick is saved

      function validateNick(n){ return /^[A-Za-z0-9]{1,12}$/.test(n); }
      async function ensureNickname(){
        if (playerNick) { canPlay = true; return; }
        // show modal and gate gameplay; don't reset if already open (avoid clearing typed text)
        if (!modalNick.classList.contains('show')) {
          openModal(modalNick);
          nickInput.value = '';
          nickError.style.display = 'none';
          setTimeout(()=>nickInput.focus(), 50);
        }
        canPlay = false;
      }
      async function trySaveNick(){
        const n = nickInput.value.trim();
        if (!validateNick(n)) { nickError.textContent = 'Only A–Z, 0–9, up to 12 chars.'; nickError.style.display = 'block'; return; }
        try {
          const exists = await provider.exists(n);
          if (exists) { nickError.textContent = 'That nickname is taken. Try another.'; nickError.style.display = 'block'; return; }
          await provider.register(n);
          playerNick = n; localStorage.setItem('player_nick', n);
          nickError.style.display = 'none'; closeModal(modalNick); canPlay = true; showToast(`Welcome, ${n}!`);
          // Push current totals if any
          await provider.upsert(playerNick, { wins: stats.wins, played: stats.played });
          // If renamed, delete previous nickname record
          if (pendingOldNick && pendingOldNick.toLowerCase() !== n.toLowerCase()) {
            try { await provider.delete(pendingOldNick); } catch {}
          }
          pendingOldNick = null;
          refreshLeaderboard();
        } catch (e) {
          nickError.textContent = 'Could not reserve nickname. Try again.'; nickError.style.display = 'block';
        }
      }
      nickConfirm.addEventListener('click', trySaveNick);
      nickInput.addEventListener('keydown', (e)=>{ if (e.key==='Enter') { e.preventDefault(); trySaveNick(); } });
      btnLeader.addEventListener('click', ()=> openModal(modalLeader));
      document.getElementById('leader-close').addEventListener('click', ()=> closeModal(modalLeader));
      btnChangeNick.addEventListener('click', ()=>{
        // Clear in-memory and stored nick and prompt again
        pendingOldNick = playerNick || null;
        playerNick = '';
        localStorage.removeItem('player_nick');
        ensureNickname();
      });

      function renderLeaderRows(rows){
        const make = (arr) => arr.map(p => `<tr><td>${sanitize(p.nick)}</td><td class="col-r">${p.wins}</td><td class="col-r">${p.played?Math.round((p.wins/p.played)*100):0}</td></tr>`).join('');
        if (leaderBody) leaderBody.innerHTML = rows.length? make(rows) : '<tr><td colspan="3" style="padding:10px 12px;color:var(--muted)">No players yet.</td></tr>';
        if (leaderBodyModal) leaderBodyModal.innerHTML = leaderBody.innerHTML;
      }
      async function refreshLeaderboard(){
        try {
          const list = await provider.list();
          list.sort((a,b)=> b.wins - a.wins || ((b.wins/(b.played||1)) - (a.wins/(a.played||1))) || a.nick.localeCompare(b.nick));
          renderLeaderRows(list);
        } catch {
          // ignore
        }
      }
      // periodic refresh
      setInterval(refreshLeaderboard, 20000);
      refreshLeaderboard();

      // --- Game constants ---
      const ROWS = 6; const COLS = 5;
      const boardEl = document.getElementById('board');
      const toastEl = document.getElementById('toast');
      const srEl = document.getElementById('sr');
      const btnNew = document.getElementById('btn-new');
  const btnHint = document.getElementById('btn-hint');

      // Stats
      const statPlayed = document.getElementById('stat-played');
      const statWin = document.getElementById('stat-win');
      const statStreak = document.getElementById('stat-streak');
      const statMax = document.getElementById('stat-max');

  // We allow any 5-letter alphabetic guess per request (not restricted to word list)

      function saveStats(s){ localStorage.setItem('cookie_wordle_stats', JSON.stringify(s)); }
      function loadStats(){
        try { return JSON.parse(localStorage.getItem('cookie_wordle_stats')) || { played: 0, wins: 0, streak: 0, maxStreak: 0 }; }
        catch { return { played: 0, wins: 0, streak: 0, maxStreak: 0 }; }
      }
      let stats = loadStats();
      function renderStats(){
        statPlayed.textContent = String(stats.played);
        statWin.textContent = stats.played ? String(Math.round((stats.wins / stats.played) * 100)) : '0';
        statStreak.textContent = String(stats.streak);
        statMax.textContent = String(stats.maxStreak);
      }
      renderStats();

      // Board generation
      const rows = [];
      const tiles = [];
      for (let r = 0; r < ROWS; r++) {
        const row = document.createElement('div'); row.className = 'row'; rows.push(row);
        const rowTiles = [];
        for (let c = 0; c < COLS; c++) {
          const t = document.createElement('div'); t.className = 'tile'; t.setAttribute('data-row', r); t.setAttribute('data-col', c);
          // Unique cookie speckle pattern per tile via deterministic RNG
          let seed = (r * COLS + c + 1) * 97;
          const rng = () => { const s = Math.sin(seed++) * 10000; return s - Math.floor(s); };
          const rand = (a,b) => a + rng() * (b - a);
          t.style.setProperty('--t-s1r', `${Math.round(rand(6,10))}px`);
          t.style.setProperty('--t-s1x', `${Math.round(rand(55,80))}%`);
          t.style.setProperty('--t-s1y', `${Math.round(rand(20,60))}%`);
          t.style.setProperty('--t-s1a', `${rand(0.15,0.30).toFixed(2)}`);
          t.style.setProperty('--t-s2r', `${Math.round(rand(4,8))}px`);
          t.style.setProperty('--t-s2x', `${Math.round(rand(20,50))}%`);
          t.style.setProperty('--t-s2y', `${Math.round(rand(50,85))}%`);
          t.style.setProperty('--t-s2a', `${rand(0.12,0.24).toFixed(2)}`);
          t.style.setProperty('--t-s3r', `${Math.round(rand(3,7))}px`);
          t.style.setProperty('--t-s3x', `${Math.round(rand(35,60))}%`);
          t.style.setProperty('--t-s3y', `${Math.round(rand(15,40))}%`);
          t.style.setProperty('--t-s3a', `${rand(0.15,0.26).toFixed(2)}`);
          t.style.setProperty('--t-s4r', `${Math.round(rand(3,6))}px`);
          t.style.setProperty('--t-s4x', `${Math.round(rand(55,75))}%`);
          t.style.setProperty('--t-s4y', `${Math.round(rand(55,85))}%`);
          t.style.setProperty('--t-s4a', `${rand(0.12,0.22).toFixed(2)}`);
          row.appendChild(t); rowTiles.push(t);
        }
        tiles.push(rowTiles); boardEl.appendChild(row);
      }

      // Keyboard
      const kb1 = 'qwertyuiop'.split('');
      const kb2 = 'asdfghjkl'.split('');
      const kb3 = ['enter', ...'zxcvbnm'.split(''), 'back'];
      const kbRows = [document.getElementById('kb-row-1'), document.getElementById('kb-row-2'), document.getElementById('kb-row-3')];
      const keyButtons = new Map();
      function mkKey(label) {
        const b = document.createElement('button');
        b.className = 'key' + (label==='enter' || label==='back' ? ' wide' : '');
        b.textContent = label === 'back' ? '⌫' : (label === 'enter' ? 'Enter' : label);
        b.setAttribute('data-key', label);
        b.addEventListener('click', () => onKey(label));
        // Unique cookie look for each key
  const seedBase = label.split('').reduce((acc,ch,i)=> acc + ch.charCodeAt(0)*(i+1), 0) + 13;
  let seed = seedBase;
  const rng = () => { const s = Math.sin(seed++) * 10000; return s - Math.floor(s); };
  const rand = (a,b) => a + rng()*(b-a);
  b.style.setProperty('--k-s1r', `${Math.round(rand(5,8))}px`);
  b.style.setProperty('--k-s1x', `${Math.round(rand(65,90))}%`);
  b.style.setProperty('--k-s1y', `${Math.round(rand(15,45))}%`);
  b.style.setProperty('--k-s1a', `${rand(0.18,0.28).toFixed(2)}`);
  b.style.setProperty('--k-s2r', `${Math.round(rand(4,7))}px`);
  b.style.setProperty('--k-s2x', `${Math.round(rand(20,45))}%`);
  b.style.setProperty('--k-s2y', `${Math.round(rand(55,85))}%`);
  b.style.setProperty('--k-s2a', `${rand(0.12,0.22).toFixed(2)}`);
        keyButtons.set(label, b);
        return b;
      }
      kb1.forEach(k => kbRows[0].appendChild(mkKey(k)));
      kb2.forEach(k => kbRows[1].appendChild(mkKey(k)));
      kb3.forEach(k => kbRows[2].appendChild(mkKey(k)));

      // Game state
  let solution = null;
      let curRow = 0; let curCol = 0; let locked = false; let finished = false;
  let hintCol = -1; let hintChar = '';
  let knownLetters = new Set(); // letters the player has already revealed (yellow or green)
  let knownCorrectPos = new Array(COLS).fill(false); // columns already solved (green)
  const disabledLetters = new Set(); // letters marked absent for this round
      function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
      function pickFromDict(){
        if (!dictReady) return null;
        if (!window._DICT5_ARR || window._DICT5_ARR.length !== DICT5.size) window._DICT5_ARR = Array.from(DICT5);
        return pick(window._DICT5_ARR);
      }

      // Track if player made at least one submitted guess this round (for forfeit handling)
      const FORFEIT_KEY = 'cookie_wordle_pending_forfeit';
      let attempted = false;

      function resetGame(newSolution){
  const pickSol = newSolution || pickFromDict();
  if (!pickSol) { showToast('Loading dictionary…'); loadDict(); return; }
  solution = pickSol; curRow = 0; curCol = 0; locked = false; finished = false; hintCol = -1; hintChar = '';
  knownLetters = new Set(); knownCorrectPos = new Array(COLS).fill(false);
        disabledLetters.clear();
        attempted = false;
        rows.forEach(r => { r.classList.remove('shake','bounce'); });
        tiles.flat().forEach(t => { t.textContent = ''; t.className = 'tile'; t.removeAttribute('data-state'); });
        keyButtons.forEach(b => { b.classList.remove('absent','present','correct'); b.removeAttribute('disabled'); b.removeAttribute('aria-disabled'); b.dataset.state = 'none'; });
        if (btnHint) { btnHint.removeAttribute('disabled'); btnHint.setAttribute('aria-disabled','false'); }
        announce(`New word. Start guessing.`);
      }

      btnNew.addEventListener('click', () => {
        if (locked) return; if (!playerNick) { ensureNickname(); return; }
        // Count as a defeat if at least one row was submitted and the round isn't finished
        if (!finished && attempted) {
          stats.played++; stats.streak = 0; saveStats(stats); renderStats();
          if (playerNick) { provider.upsert(playerNick, { wins: stats.wins, played: stats.played }).then(refreshLeaderboard).catch(()=>{}); }
          localStorage.removeItem(FORFEIT_KEY);
        }
        resetGame();
      });
      btnHint.addEventListener('click', () => {
  if (locked || finished) return;
        if (!playerNick) { ensureNickname(); return; }
        if (hintCol !== -1) { showToast('Hint already used'); return; }
        // Pick a column that is not already solved (green) and whose solution letter hasn't been revealed (no yellow/green yet)
        const candidates = [];
        for (let c=0;c<COLS;c++) {
          const ch = solution[c];
          if (!knownCorrectPos[c] && !knownLetters.has(ch)) candidates.push(c);
        }
        if (candidates.length === 0) { showToast('No new hint available'); return; }
        const col = candidates[Math.floor(Math.random()*candidates.length)];
        hintCol = col; hintChar = solution[col];
  // Fill and lock current and future rows at that column with the revealed char
  for (let r=curRow;r<ROWS;r++) {
          const t = tiles[r][col];
          t.textContent = hintChar.toUpperCase();
          t.classList.add('hint');
          t.setAttribute('data-hint','1');
        }
        // If current cursor was at hint column, move forward
  if (curCol === hintCol) curCol = Math.min(curCol+1, COLS);
  if (btnHint) { btnHint.setAttribute('disabled',''); btnHint.setAttribute('aria-disabled','true'); }
        showToast(`Hint: ${hintChar.toUpperCase()} is in position ${col+1}`);
      });

      function showToast(msg, ms=1200) {
        toastEl.textContent = msg;
        const wide = window.matchMedia('(min-width: 900px)').matches;
        if (wide) {
          const wrap = boardEl.closest('.board-wrap') || boardEl;
          const rect = wrap.getBoundingClientRect();
          const spaceLeft = rect.left;
          const spaceRight = window.innerWidth - rect.right;
          const placeLeft = spaceLeft > spaceRight; // choose side with more space
          toastEl.classList.add('side');
          toastEl.classList.toggle('left', placeLeft);
        } else {
          toastEl.classList.remove('side');
          toastEl.classList.remove('left');
        }
        toastEl.classList.add('show');
        clearTimeout(showToast._t); showToast._t = setTimeout(() => toastEl.classList.remove('show'), ms);
      }
      function announce(msg){ srEl.textContent = msg; }

      function setTile(r,c,ch){ const t = tiles[r][c]; t.textContent = ch.toUpperCase(); t.classList.add('pop'); setTimeout(()=>t.classList.remove('pop'), 100); }
      function clearTile(r,c){ const t = tiles[r][c]; t.textContent=''; }

      function onKey(k){
  if (locked) return;
  if (!playerNick) { ensureNickname(); return; }
        if (finished) return; // wait for Next word
        if (k === 'enter') return submitGuess();
        if (k === 'back') return backspace();
        if (/^[a-z]$/.test(k)) {
          if (disabledLetters.has(k)) return; // don't allow absent letters this round
          if (curCol < COLS) {
            // Skip locked hint column
            if (hintCol !== -1 && curCol === hintCol) curCol++;
            if (curCol < COLS) { setTile(curRow, curCol, k); curCol++; }
          }
        }
      }

      function backspace(){
        if (curCol>0) {
          // If previous is hint column, step back twice
          if (hintCol !== -1 && curCol-1 === hintCol) { curCol -= 2; }
          else { curCol--; }
          if (curCol < 0) { curCol = 0; return; }
          // Avoid clearing hint cell
          if (hintCol !== -1 && curCol === hintCol) return;
          clearTile(curRow, curCol);
        }
      }

      function getGuess(r){ return tiles[r].map(t => (t.textContent||'').toLowerCase()).join(''); }

      function submitGuess(){
  if (!playerNick) { ensureNickname(); return; }
        const guess = getGuess(curRow);
        if (guess.length < COLS) { rows[curRow].classList.add('shake'); setTimeout(()=>rows[curRow].classList.remove('shake'), 300); showToast('Not enough letters'); return; }
  // Accept only real English 5-letter words
  if (!/^[a-z]{5}$/.test(guess)) { rows[curRow].classList.add('shake'); setTimeout(()=>rows[curRow].classList.remove('shake'), 300); showToast('Use letters A–Z'); return; }
  if (!dictReady) { showToast('Loading dictionary…'); loadDict(); return; }
  if (!DICT5.has(guess)) { rows[curRow].classList.add('shake'); setTimeout(()=>rows[curRow].classList.remove('shake'), 300); showToast("We don't accept that"); return; }
        // Enforce hint position if used
        if (hintCol !== -1 && guess[hintCol] !== hintChar) { rows[curRow].classList.add('shake'); setTimeout(()=>rows[curRow].classList.remove('shake'), 300); showToast(`The ${hintCol+1}ᵗʰ letter must be ${hintChar.toUpperCase()}`); return; }
  // First valid submission in this round: mark attempt and set pending-forfeit flag in case of refresh/skip
  if (!attempted) { attempted = true; try { localStorage.setItem(FORFEIT_KEY, '1'); } catch {} }
        revealRow(guess);
      }

      function computeResult(guess, answer){
        // Wordle letter eval with duplicates
        const res = new Array(COLS).fill('absent');
        const counts = new Map();
        for (let i=0;i<COLS;i++) { const a = answer[i]; counts.set(a, (counts.get(a)||0)+1); }
        // First pass: correct
        for (let i=0;i<COLS;i++) {
          if (guess[i] === answer[i]) { res[i] = 'correct'; counts.set(guess[i], counts.get(guess[i]) - 1); }
        }
        // Second pass: present
        for (let i=0;i<COLS;i++) {
          if (res[i] === 'correct') continue;
          const g = guess[i];
          if ((counts.get(g)||0) > 0) { res[i] = 'present'; counts.set(g, counts.get(g)-1); }
        }
        return res;
      }

      function updateKeyboard(guess, result){
        const rank = { none: -1, absent: 0, present: 1, correct: 2 };
        for (let i=0;i<COLS;i++){
          const ch = guess[i]; const b = keyButtons.get(ch); if (!b) continue;
          const r = result[i];
          const cur = b.dataset.state || 'none';
          if (rank[r] > rank[cur]) {
            b.dataset.state = r;
            b.classList.remove('absent','present','correct');
            b.classList.add(r);
          }
          // Disable absent letters for the rest of the round; re-enable if later upgraded
          const state = b.dataset.state;
          if (state === 'absent') { b.setAttribute('disabled',''); b.setAttribute('aria-disabled','true'); disabledLetters.add(ch); }
          else if (state === 'present' || state === 'correct') { b.removeAttribute('disabled'); b.removeAttribute('aria-disabled'); disabledLetters.delete(ch); }
        }
      }

      function revealRow(guess){
        locked = true;
  const res = computeResult(guess, solution);
  const rowTiles = tiles[curRow];
  // Remove hint highlight from the row being revealed so state colors show clearly
  rowTiles.forEach(t => t.classList.remove('hint'));
        rowTiles.forEach(t => t.classList.add('revealed'));
        // flip each with delay
        res.forEach((state, i) => {
          setTimeout(() => {
            const t = rowTiles[i];
            t.classList.add('flip');
            setTimeout(() => {
              t.classList.remove('flip');
              t.classList.add(state);
              t.setAttribute('data-state', state);
              if (i === COLS-1) { // last
                updateKeyboard(guess, res);
                afterReveal(guess, res);
              }
            }, 300);
          }, i * 260);
        });
      }

      function afterReveal(guess, res){
        // Update knowledge from this row's result
        for (let i=0;i<COLS;i++) {
          if (res[i] === 'correct') { knownCorrectPos[i] = true; knownLetters.add(guess[i]); }
          else if (res[i] === 'present') { knownLetters.add(guess[i]); }
        }
        const win = res.every(s => s === 'correct');
        if (win) {
          rows[curRow].classList.add('bounce');
          finished = true; locked = false;
          stats.played++; stats.wins++; stats.streak++; stats.maxStreak = Math.max(stats.maxStreak, stats.streak); saveStats(stats); renderStats();
          // push leaderboard totals
          if (playerNick) { provider.upsert(playerNick, { wins: stats.wins, played: stats.played }).then(refreshLeaderboard).catch(()=>{}); }
          // Clear any pending forfeit (round concluded)
          localStorage.removeItem(FORFEIT_KEY);
          showToast(['Nice!','Clean!','Sharp!','Neon!'][Math.floor(Math.random()*4)], 1400);
          announce('You guessed it!');
          return;
  }

        curRow++; curCol = 0; locked = false;
        // If hint is active, prefill the next row's hint cell and place cursor after it
        if (!finished && hintCol !== -1 && curRow < ROWS) {
          const t = tiles[curRow][hintCol];
          t.textContent = hintChar.toUpperCase();
          t.classList.add('hint'); t.setAttribute('data-hint','1');
          // Place cursor at the first editable cell (leftmost non-hint column)
          curCol = hintCol === 0 ? 1 : 0;
        }
        if (curRow >= ROWS) {
          finished = true; stats.played++; stats.streak = 0; saveStats(stats); renderStats();
          // push leaderboard totals (loss)
          if (playerNick) { provider.upsert(playerNick, { wins: stats.wins, played: stats.played }).then(refreshLeaderboard).catch(()=>{}); }
          // Clear any pending forfeit (round concluded)
          localStorage.removeItem(FORFEIT_KEY);
          showToast(`The word was "${solution.toUpperCase()}"`, 1800);
          announce(`Game over. The word was ${solution}.`);
        }
      }

      // Physical keyboard
      window.addEventListener('keydown', (e) => {
        // Ignore global key handling when a modal is open or typing in inputs
        if (modalNick.classList.contains('show') || modalLeader.classList.contains('show')) return;
        const tag = (e.target && e.target.tagName || '').toLowerCase();
        if (tag === 'input' || tag === 'textarea' || (e.target && e.target.isContentEditable)) return;
        const k = e.key.toLowerCase();
        if (k === 'enter') onKey('enter');
        else if (k === 'backspace' || k === 'delete') onKey('back');
        else if (k.length === 1 && k >= 'a' && k <= 'z') onKey(k);
      });

      // Helper: small seed of solved word in console for testing (comment out in prod)
      // console.log('Solution:', solution);

  // On load: if a previous round was abandoned after at least one submission, count it as a defeat
  (function handlePendingForfeitOnLoad(){
    try {
      if (localStorage.getItem(FORFEIT_KEY)) {
        stats.played++; stats.streak = 0; saveStats(stats); renderStats();
        if (playerNick) { provider.upsert(playerNick, { wins: stats.wins, played: stats.played }).then(refreshLeaderboard).catch(()=>{}); }
        localStorage.removeItem(FORFEIT_KEY);
      }
    } catch {}
  })();

  // Start: enforce nickname, then start game
  ensureNickname().then(()=>{ if (playerNick) resetGame(); });
    </script>
  </body>
</html>
